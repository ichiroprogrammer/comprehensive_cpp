<!-- ./md/debug.md -->
# デバッグ <a id="SS_15"></a>
ソフトウェア開発にバグは付き物であり、プログラマの工数の多くはそのバグの修正に費やされる。
したがってデバッグの効率化はソフト開発効率改善の大きなポーションを占める。
このドキュメントの提言の多くはそのためのものであるが、色々な文脈に分散しており、
またそのときの論旨とは違ったため解説が不十分であったりする。

この問題を幾分緩和するためにこの章を設ける。

バグには以下のような様々な発生パターンがある。

* ある操作で100％発生するバグ
* ある操作の繰り返しによって発生するバグ
    * メモリやファイルハンドルのリークのように少しづつ劣化していくようなバグ
* ランダムに発生するように見えるバグ
    * マルチスレッドの競合問題のような確率論的にしか発生しないバグ
    * メモリ二重解放によるクラッシュのような発生パターの特定が難しいバグ
    * デッドロック

当然ながら発生パターンの違いはデバッグ手法の有効性に大きく影響する。

共有リポジトリ内のソースコードにバグが多ければ、プログラマは各人の開発に集中できず、
それ自体が新たなバグの発生源となる。
また、共有リポジトリ内のソースコードのデバッグを行った為に、
そのプログラマの新規機能開発に充てられる工数は不足し、
これによるテスト不足は共有リポジトリ内のソースコードの新たなバグにつながる。と考えれば、
共有リポジトリ内のソースコードをクリーンに保つことも、
デバッグの効率化への重要な戦略であるといえる。

ここまでの議論からわかるように、デバッグの効率化とは、単なるデバッグ手法にとどまらず、
共有リポジトリ内のソースコードをクリーンに保つようなプロセス的な手法も包含する広範囲な内容となる。
以下に、そのための様々なアイテムを説明する。

___

__この章の構成__

&emsp;&emsp; [デバッガの使用](debug.md#SS_15_1)  
&emsp;&emsp; [gitの使用](debug.md#SS_15_2)  
&emsp;&emsp; [TATの短縮](debug.md#SS_15_3)  
&emsp;&emsp;&emsp; [ビルド時間の短縮](debug.md#SS_15_3_1)  
&emsp;&emsp;&emsp; [依存関係の整理](debug.md#SS_15_3_2)  

&emsp;&emsp; [自動単体テストの実施](debug.md#SS_15_4)  
&emsp;&emsp; [自動統合テストの実施](debug.md#SS_15_5)  
&emsp;&emsp; [事後的デバッグ](debug.md#SS_15_6)  
&emsp;&emsp;&emsp; [ログの取得](debug.md#SS_15_6_1)  
&emsp;&emsp;&emsp; [モニター](debug.md#SS_15_6_2)  

&emsp;&emsp; [潜在的バグの削減](debug.md#SS_15_7)  
&emsp;&emsp; [難しいバグの対処](debug.md#SS_15_8)  
&emsp;&emsp; [助成の依頼](debug.md#SS_15_9)  
&emsp;&emsp;&emsp; [現象1 - 不思議なハングアップ](debug.md#SS_15_9_1)  
&emsp;&emsp;&emsp; [現象2 - グローバル変数の破壊](debug.md#SS_15_9_2)  
&emsp;&emsp;&emsp; [現象3 - プロセスのスローダウン](debug.md#SS_15_9_3)  
&emsp;&emsp;&emsp; [現象4 - バックトレースが見れない](debug.md#SS_15_9_4)  
&emsp;&emsp;&emsp; [現象5 - newしたオブジェクトの破壊](debug.md#SS_15_9_5)  
&emsp;&emsp;&emsp; [現象6 - STLのバグ?](debug.md#SS_15_9_6)  
&emsp;&emsp;&emsp; [現象7 - 解放後のrvalueへのアクセス](debug.md#SS_15_9_7)  

&emsp;&emsp; [まとめ](debug.md#SS_15_10)  
  
  

[インデックス](introduction.md#SS_1_4)に戻る。  

___

## デバッガの使用 <a id="SS_15_1"></a>
言うまでもなく特定操作で100%発生するバグのデバッグには、デバッガの使用が適している。
windowsアプリケーションの開発では、Visual Studioが素晴らしいデバッガを提供しているため、
それを使い、ステップ実行すればまず間違いなく短時間でバグを特定できる。
linux系のアプリケーション開発においてはgdb/lldbで同様のことが言える。

問題は組み込みソフト開発の現場である。
printfデバッグが唯一のデバッグ手段となっているエンジニアをよく見かける。こういった現場では
jtagデバッガを使えば大きな改善が期待できる。

また、「[自動単体テストの実施](debug.md#SS_15_4)」に従えば、組み込みソフト開発においても、
先に述べたような優れたデバッガを使用できる。

ランダムに発生するようなバグにおいても、デバッガは有効であることがある。
このようなバグではステップ実行でその原因を特定できないが、例えばデッドロックが起こった場合は、

* デッドロックが起こったプロセスをデバッガにアタッチさせてスレッドの状態を見る
* メモリダンプを取り、デバッガでスレッドの状態を見る(linuxでもwindowsでも同様のことはできる)

のような手法が有効である。

## gitの使用 <a id="SS_15_2"></a>
言うまでもないが、新規機能を追加した後にすでに動いていた機能が動かなくなったのであれば、
新規コードが原因であると考えるのが常識的である。
このようなデグレードの原因を効率的に発見するためには、
コード追加前後での差分を見るのが理にかなっている。
[バージョン管理システム](process_and_infra.md#SS_11_2_5_1)を使えば、これを正確かつ簡単に行うことができる。

複数人でソフトウェア開発を行う場合、頻繁に各人の作り出すソースコードをマージする必要がある。
マージにはある一定確率でのバグ混入は避けられず、
バグが発生すればこれを直ちに修正するのが合理的なチーム運営である。
[バージョン管理システム](process_and_infra.md#SS_11_2_5_1)を使わずに、これを行うことは難しい。

リリースしたソフトウェアの異常動作が報告されたときに、
そのバイナリコードを生成したソースコードに完全に一致するソースコードを使用せずに、
その原因を特定することは、ほぼ不可能である。
[バージョン管理システム](process_and_infra.md#SS_11_2_5_1)を使わずにこれを行うことも上記同様に難しい。

このような理由(他にも多数の理由はある)から、
[バージョン管理システム](process_and_infra.md#SS_11_2_5_1)の導入には議論の余地はないが、
数あるバージョン管理システムの中から何を選ぶのかは意見の分かれるところである。

本ドキュメントでは以下のような観点からgitを推奨する。

* 現在も活発に開発されている。
* ウェブドキュメントや書籍が豊富である。
* クラウドサービスがある。
* ライセンス費用がない。
* 有名なオープンソース管理に使用されている。
* 多くのオープンソース管理に使用されているため、
  gitの知識は現在のプログラマにとって常識となっている。

gitには以下のような基本的なコマンドに加えて、

* add/commit - ソースコードのリポジトリへの登録
* branch/checkout/reset - ブランチ操作
* merge - ブランチ間のマージ
* log - コミットログ

リポジトリの分散をサポートする下記のようなコマンドがある。

* fetch/pull - リモートブランチからの差分取り込み
* push - リモートブランチへの差分転送
* rebase - カレントブランチをリモートブランチに同期

他にも多数のコマンドがあるが、中でも有用なのが、 

* bisect - デバッグサポート

である。以下にbisectの使い方を例示する。

本ドキュメントでは、「[開発プロセスとインフラ](process_and_infra.md#SS_11)」で述べたように、単体テスト、
統合テストを自動化することを推奨している。

本ドキュメントで使用するディレクトリやファイル間の依存関係を解析するためのソフトウェア
[deps](deps.md#SS_17)の開発においても、当然これを実践している。

depsの開発においては、単体テスト、統合テストは下記のようなdeps/build.shによって行われる。

```sh
    //  deps/example/deps/build.sh 3

    readonly BASE_DIR=$(cd $(dirname $0); pwd)
    readonly BASENAME="$(basename $0)"

    $BASE_DIR/../../deep/build/build_core.sh $BASE_DIR $@ -i
    # build_core.shによって下記が行われ、何らかのエラーが発生した場合、非0でexitする。
    # * ビルド & UT & IT
    # * 静的解析
    # * 動的解析
```

depsが、

* xxxリビジョンまでは、build.shが成功(値0でexit)
* yyyリジョンでは、build.shが失敗(非0でexit)

のような状態に陥ったとする([CI(継続的インテグレーション)](process_and_infra.md#SS_11_2_5)を導入しているソフトウェア開発では、
このような状態は珍しいことでない)。
この場合、バグが混入したリビジョンを確定することがデバッグの第一歩となる。
bisectはこれをダイレクトにサポートする。

```sh
    git bisect start xxx yyy
    git bisect run deps/build.sh
```

上記コマンドは、xxx～yyyのリビジョン毎にbuild.shを実行し、build.shが非0でexitした場合、
そこで停止する。これによりバグが混入したリビジョンをほぼ工数をロスすることなしに確定できる。

## TATの短縮 <a id="SS_15_3"></a>
TATとはターンアラウンドタイムの略語であり、一度の試行に要する時間を指す。
デバッグのTATが短ければ短いほどデバッグ効率が良くなることは明らかだろう
(これとは対をなす概念が「[事後的デバッグ](debug.md#SS_15_6)」である)。

再現性の悪いバグには、様々なテストパターンを試す、環境を変えてみる、
等の運任せの手法も時には必要になるが、以下のような戦略的アプローチが最も有効である。

* printfデバッグを使わない(「[デバッガの使用](debug.md#SS_15_1)」参照)
* [ビルド時間の短縮](debug.md#SS_15_3_1)
* [自動単体テストの実施](debug.md#SS_15_4)(ターゲットハードウェアへのプログラム転送が不要なため、
  組み込みソフト開発には特に有効である)

### ビルド時間の短縮 <a id="SS_15_3_1"></a>
ビルド時間を短くするためには、下記等が施策となる。

* コンパイルの並列化を行う(make -j等)
* ライブラリに細かく分割する(コンパイルの並列化がされやすくなる)
* コア数/スレッド数が多く、SSD等のストレージアクセスが早く、メモリが多いコンパイルマシンをを使う
* 差分ビルドが有効に働くように、[依存関係の整理](debug.md#SS_15_3_2)を行う
* 不要なインクルードを行わない
  (静的解析ツールによっては、不要なインクルードを指摘してくれる)

ビルドツールが並列コンパイルをサポートしているのであれば
(「[コンパイラ](dev_tools.md#SS_16_1)」で述べたしたメーカのIDEは並列コンパイルができなかった)、
上記したような高スペックのビルドマシンを導入することで、
工数負担なしにコンパイル時間の改善ができる。
多少費用は増えるが、人件費とは比較にならないほど安価である(「[開発ツール](dev_tools.md#SS_16)」参照)。

各プログラマがフルビルドを一日に何度も行うことはないので、
実践的には差分ビルドが有効になるように依存関係を見直すのが良い。
ただし、これには「[依存関係の整理](debug.md#SS_15_3_2)」で説明したような努力が必要である。

### 依存関係の整理 <a id="SS_15_3_2"></a>
「[パッケージとその構成ファイル](programming_convention.md#SS_3_7)」で述べたようにソースコードをパッケージ分割し、
そのパッケージをライブラリとしてまとめ、ライブラリ間の循環依存がないようにすることで、
差分ビルドは有効に働くことが多い(その場合、当然無駄なインクルードもしない必要がある)。

このようなライブラリ構成は、

* 単体テストが容易になる(「[自動単体テスト](process_and_infra.md#SS_11_2_1)」参照)
* 修正後の影響範囲を明確にしやすい
* ライブラリの転用がしやすい

等他にも良い影響があるため、この構造を維持するべきである。
そのためには、

* 静的解析ツール等を使った依存関係の監視(「[deps](deps.md#SS_17)」参照)
* ビルドツールの使い方の工夫(「[makeによる依存関係の維持](deps.md#SS_17_3)」参照)

等が必要になる。

## 自動単体テストの実施 <a id="SS_15_4"></a>
[自動単体テスト](process_and_infra.md#SS_11_2_1)は、

* デバッグのTATを短縮できる(「[TATの短縮](debug.md#SS_15_3)」参照)
* 統合テストでは実施困難なテストを行うことができる
* ほぼ工数をかけることなく、回帰テストを実施できるため、
  共有リポジトリ内のソースコードをクリーンに保てる
* カバレッジを取ることで、テストが不十分なコードを特定できる

等の効果を期待できるため、現在のソフトウェア開発において欠かすことができない手法である。


## 自動統合テストの実施 <a id="SS_15_5"></a>
[自動統合テスト](process_and_infra.md#SS_11_2_3)は、

* ほぼ工数をかけることなく、回帰テストを実施できるため、
  共有リポジトリ内のソースコードをクリーンに保てる
* 長時間操作が必要なテスト(メモリーリークや、発生率の悪いタイミング問題等)を、
  人手をかけずに実施できる
* git bisect(「[gitの使用](debug.md#SS_15_2)」参照)と組み合わせれば、
  デグレードが起こった共有リポジトリのリビジョンを特定できる

等の効果を期待できるため、現在のソフトウェア開発において欠かすことができない手法である。

[deps](deps.md#SS_17)に関しても、以下のシェルスクリプトにより自動統合テストを実現している。

```sh
    //  deps/example/deps/it.sh 6

    function help(){
        echo "$BASENAME  [option]"
        echo "    -a BIN : BIN is test target(default:./g++/deps)"
        echo "    -d     : debug mode"
        echo "    -h     : show this message"

        exit $1
    }

    // ...

    function test_a2pu() {
        local -r exp=$1
        local -r in=$2
        local -r act=${exp}.act
        rm -f $act

        $APP a2pu -i $in -o $act $dir
        diff $exp $act

        rm $act
    }

    // ...

    echo test_a 0         && test_a it_data/a_ut_data.txt it_data/p2p_ut_data.txt 
    echo test_a2pu 0      && test_a2pu it_data/pu_ut_data.pu it_data/p2p_ut_data.txt 
    echo test_a2pu 1      && test_a2pu it_data/pu_ut_data_s.pu it_data/p2p_ut_data_s.txt
    echo test_deps_fake   && test_deps_fake
    echo test_deps_dep    && test_deps_dep
    echo test_deps_dep2   && test_deps_dep2
```

上記でも使ったunix系のコマンドは、

* 統合テストのみならず、様々な自動化に関して非常に強力なツールである
* [cygwin](https://www.cygwin.com/)によりwindows上でもunixでの使用感とほぼ同等に使える

ため、
[The Art  of  Command  Line](https://github.com/jlevy/the-art-of-command-line/blob/master/README-ja.md)
等を参考に学習するべきである。

## 事後的デバッグ <a id="SS_15_6"></a>
多くのバグは、組織の公式なテストやユーザによって発見されるため(ユーザには発見されたくないが)、
その解析にデバッガが使えないことはよくあることである。
このような場合でも、ホスト上のソフトウェアであれば、
メモリダンプを取り、事後的にデバッガを利用することはできるが、
このアプローチが必ずしも効果的とは限らない。
また、組み込みソフトの場合、メモリダンプの取得ですら簡単ではない。

ここでは、そのような場合に有効な手法について解説する。

### ログの取得 <a id="SS_15_6_1"></a>
第三者によってバグが報告された場合、
デバッグのファーストステップは、そのバグを手元で再現させることになるが、
その第三者からバグ発生時の正確な手順を聞き出すことは困難である。また、聞き出せたとしても、
もし、そのバグが簡単に再現しない場合、その手順を完全に信じることは難しい。

こういったことに備えるために、
ソースコードにあらかじめログを仕込んでおくことは昔から行われてきており、今なお有効な手法である。

[deps](deps.md#SS_17)の開発にもログは有効であり、

* ログ取得用のクラスと関数テンプレート
  (「[ログ取得ライブラリの開発](template_meta_programming.md#SS_13_1)」、「[ログ取得ライブラリの開発2](template_meta_programming.md#SS_13_6)」参照)

```cpp
    //  deps/example/deps/logging/h/logging/logger.h 11

    namespace Logging {
    class Logger {
    public:
        static Logger& Inst(char const* filename = nullptr);

        template <typename HEAD, typename... TAIL>
        void Set(char const* filename, uint32_t line_no, HEAD const& head, TAIL... tails)
        {
            auto   path     = std::string_view{filename};
            size_t npos     = path.find_last_of('/');
            auto   basename = (npos != std::string_view::npos) ? path.substr(npos + 1) : path;

            os_.width(12);
            os_ << basename << ":";

            os_.width(3);
            os_ << line_no;

            set_inner(head, tails...);
        }

        // ...

    private:
        void set_inner() { os_ << std::endl; }

        template <typename HEAD, typename... TAIL>
        void set_inner(HEAD const& head, TAIL... tails)
        {
            using Nstd::operator<<;
            os_ << ":" << head;
            set_inner(tails...);
        }

        template <typename HEAD, typename... TAIL>
        void set_inner(char sep, HEAD const& head, TAIL... tails)
        {
            using Nstd::operator<<;
            os_ << sep << head;
            set_inner(tails...);
        }

        // ...
    };
    }  // namespace Logging

    #define LOGGER_INIT(filename) Logging::Logger::Inst(filename)
    #define LOGGER(...) Logging::Logger::Inst().Set(__FILE__, __LINE__, __VA_ARGS__)
```

* オブジェクトを文字列変換するため関数

```cpp
    //  deps/example/deps/app/src/deps_opts.h 53

    std::string          ToStringDepsOpts(DepsOpts const& deps_opts, std::string_view indent = "");
    inline std::ostream& operator<<(std::ostream& os, DepsOpts const& opts) { return os << ToStringDepsOpts(opts); }
```

* ログの取得方法

```cpp
    //  deps/example/deps/app/src/main.cpp 43
    std::unique_ptr<Dependency::ScenarioGenerator> gen_scenario(App::DepsOpts const& opt)
    try {
        using namespace Dependency;

        switch (opt.GetCmd()) {
        case App::DepsOpts::Cmd::GenPkg:
            LOGGER("start GenPkg");
            return std::make_unique<PkgGenerator>(opt.In(), opt.IsRecursive(), opt.Dirs(), opt.Exclude());
        case App::DepsOpts::Cmd::GenSrc:
            LOGGER("start GenPkg");
            return std::make_unique<SrcsGenerator>(opt.In(), opt.IsRecursive(), opt.Dirs(), opt.Exclude());
            // ...
        }
    }
    catch (std::runtime_error const& e) {
        LOGGER("error occured:", e.what());

        std::cerr << e.what() << std::endl;

        return std::make_unique<ScenarioGeneratorNop>(false);
    }

    // ...

    int main(int argc, char* argv[])
    {
        App::DepsOpts d_opt{argc, argv};

        LOGGER_INIT(d_opt.Log() == "-" ? nullptr : d_opt.Log().c_str());

        LOGGER("Options", '\n', d_opt);

        auto out_sel   = OStreamSelector{d_opt.Out()};
        auto exit_code = gen_scenario(d_opt)->Output(out_sel.OStream()) ? 0 : -1;

        LOGGER("Exit", exit_code);

        return exit_code;
    }
```

によりログを取得している。これにより以下のような内容のログファイルが取得できる。

```
    app/src/main.cpp:109:Options
    cmd       : GenPkg
    in        : 
    out       : 
    recursive : true
    src_as_pkg: false
    log       : it_data/log_exp.txt.act
    dirs      : ut_data
    exclude   : 
    parsed    : true
    app/src/main.cpp: 51:start GenPkg
    app/src/main.cpp:114:Exit:0
```

なお、組み込みソフトの場合、ファイルが使えないこともよくあるため、ログをメモリ上にストアし、
[モニター](debug.md#SS_15_6_2)の機能によりそれを吸い上げる必要がある(ファイルが使える場合にもこれは同様である)。

### モニター <a id="SS_15_6_2"></a>
先に書いた通り、組み込みソフトの場合、バグ発生後にメモリダンプを取り、
後からデバッガで調査することは難しい。
また、ログを取っていた場合でもそれを吸い上げる方法が無ければ、それを利用できない。
このような場合には、あらかじめデバッグ用の機能を入れることが有効である。
本ドキュメントではこういった機能をモニタープログラム、あるいは単にモニターと呼ぶ。

モニターには以下のような機能が必要である。

* ホスト上のターミナルソフト([Tera Term](https://ja.osdn.net/projects/ttssh2/)等)
  と接続するため入出力(通常はuartを利用)
* 下記のコマンドを実装するため簡易シェル([ntshell](https://cubeatsystems.com/ntshell/)等)
* メモリに保存されたログの出力
* デバッガの基本機能
    * メモリダンプ 
    * メモリ(回路のレジスタ等)への書き込み
    * レジスタダンプ(各種レジスタやCPUの状態の表示)
    * リアルタイムOSのリソースの表示
    * スレッドの状態の表示や[スタック消費量の計測](debug.md#SS_15_6_2_2)
    * [メモリ保護機能](debug.md#SS_15_6_2_1)のON/OFF
    * グローバルなnew/deleteの使用状況(「[グローバルnew/deleteのオーバーロード](dynamic_memory_allocation.md#SS_14_4_1)」参照)

レジスタダンプは、CPU例外場所の特定やコールスタックの構築には欠かせない機能であるが、
使用しているCPUやコンパイラの仕様を理解しなければ実装できない。
ARMを使っているのであれば、
[https://developer.arm.com/](https://developer.arm.com/)
等のネットドキュメントに十分情報が掲載されている。
他のランタイム系にも同様のドキュメントは提供されているはずである。

実装難度が高い、もしくは時間がない等の理由でこういった機能の実装をおろそかにすれば、
必ずと言っていいほど極度に解析困難なバグに悩まされることになる。


#### メモリ保護機能 <a id="SS_15_6_2_1"></a>
組み込みソフトは、仮想アドレスを使わず、
直接ハードウエアアドレスを使って動作することが一般的である。
その場合、CPUのデフォルトの設定では、リードオンリー領域
(インストラクション、文字列リテラル、constなPOD等)に対してもライトアクセスできるため、
例えば、クラスへのポインタにnullptrが代入された状態で、
そのポインタをデリファレンスし、ライト系のメンバ関数を呼び出せば(ptr->f()のような呼び出し)、
０アドレス付近のコードが破壊される。

多くのCPUでは、この領域には割り込みベクタが配置されているため、CPU例外が発生する。
それを捕捉する機能が実装されていなければソフトは暴走する。
CPU例外を捕捉する機能が実装されている場合でも、
その例外コードは「不正なインストラクションの実行」を示すことがほとんどであるため、
真の原因特定は難しい。

使用しているCPUがメモリ保護機能(MMUやMPUと呼ばれることが多い)をサポートしているのであれば、
それを使いリードオンリー領域を保護することで、このような状況を回避することができる。

適切にメモリ保護機能を活性化した状態でも、リードオンリー領域にライトアクセスした場合、
やはりCPU例外が発生するが、CPU例外を捕捉し、その時のレジスタをダンプすれば、
「リードオンリー領域にライトアクセスしたインストラクションが配置されているアドレス」
を特定することができる。
後は、ツールチェーンに付属するaddr2line、readelf、objdump、nmのようなバイナリ解析ツールを使い、
アドレスからソースコードを特定すればよい。

ただし、jtagデバッガを使用する場合、メモリ保護機能の設定には注意が必要である。

jtagデバッガがブレークポイントを設定する方法は2つある。一つはハードウェアブレークであり、
他方はソフトウェアブレークである。ソフトウェアブレークを設定する場合、
デバッガは、一時的に「ブレークを指定されたソースコードに対応するインストラクション」
に「ソフトウェアブレークするためのインストラクション」を上書きする。

メモリ保護をしている場合、jtagデバッガによるこの動作はCPU例外を発生させることがある。
これを避けるためには、一時的にメモリ保護機能を不活性にすればよい。
これをモニターから実行できるコマンドとして実装すると便利である。


#### スタック消費量の計測 <a id="SS_15_6_2_2"></a>
強固なメモリ保護を持つOS上のソフトウェアがスタックのオーバーフローを起こした場合、
それを示す例外コードが、コアダンプ等の何らかの方法で通知されるため、
多くの場合、デバッグはそれほど困難ではない。

組み込みソフトの場合でのスタックオーバーフローは、
「スタックに割り当てられたメモリのすぐ上にある領域が破壊される」
というデバッグ困難な現象を引き起こす
(これにより、メモリ破壊だけではなくスレッドの暴走等も起こり得る)。

こういったことを防ぐには、スタックをある特定のバイト列(0xdeadbeaf等)でフィルし、
スタックの消費量を計測できるようにすることが重要である
(0xdeadbeafでないデータが書き込まれている最上位アドレスまでが使われたと判断できる)。
当然ながらスタックの消費量を表示するコマンドはモニターから実行できれば便利である。


## 潜在的バグの削減 <a id="SS_15_7"></a>
すでに述べたように共有リポジトリ内のソースコードをクリーンに保つことは、デバッグの効率化に繋がる。
そのためにの手段として以下の三点が有効である。

* [コードインスペクション](process_and_infra.md#SS_11_2_5_1_2)   
* コードの静的解析
    * [コンパイラによる静的解析](code_analysis.md#SS_4_1)  
    * 静的解析ツールの使用  
      静的解析ツールを選択する最も重要な基準は、
      S/N比である(S(シグナル)とはバグやバグに近いコードであり、
      N(ノイズ)とは修正の必要のないコードである)。S/N比が悪いと、
      早晩プログラマはこのツールの指摘を無視し始める。
      ツールの指摘を確認するようにプロセス的に強制しても、おざなりな対応が行われるだけなので、
      S/N比の良い下記のようなツールを選ぶべきである。

        * scan-build(「[scan-buildによる静的解析](code_analysis.md#SS_4_2)」参照、ライセンス費フリー)
        * [coverity](https://www.synopsys.com/ja-jp/software-integrity/security-testing/static-analysis-sast.html)

* コードの動的解析
    * コードにassert()を入れる。
      これは外部ツールではなく、標準ヘッダcassertをインクルードすれば使用できる
      (「[assertion](programming_convention.md#SS_3_11_1)」参照)。
    * g++/clang++を使用しているのであれば、マクロ\_GLIBCXX_DEBUGを定義してビルドを行うことで、
      STLの誤使用に関するバグが指摘される。多くのコンパイラがこのような機能を持っている
      (Visual Studioでは、コンパイラの/MDdオプションをを指定する)。
    * 動的解析ツールの使用  
      sanitizer(「[sanitizerによる動的解析](code_analysis.md#SS_4_4)」参照)やvalgrind等が優れている。
      [LeakTracer](http://www.andreasen.org/LeakTracer/)等のメモリリーク専用のツールもある。

静的解析ルールと違い動的解析ツールは、プログラムを動作させなければバグを発見できないが、
[CI(継続的インテグレーション)](process_and_infra.md#SS_11_2_5)と組み合わせれば、
効率的に運用できる(「[自動統合テストの実施](debug.md#SS_15_5)」参照)。

なお、[deps](deps.md#SS_17)に関しても、以下のようにすることで単体テスト、
統合テスト時にsanitizerによる動的解析を行っている。

```Makefile
    //  deps/example/deps/Makefile 174

    ut: $(EXES_UT_DONE)  # 単体テスト用ターゲット

    it: $(EXE_IT_DONE)  # 統合テスト用ターゲット

    SANITIZER_DIR=sanitizer/
    .PHONY : sanitizer
    san:  # g++ sanitizerビルド
    	$(MAKE) O=$(SANITIZER_DIR) \
    		SANITIZER_OPT="-fsanitize=address,leak,undefined,float-divide-by-zero,float-cast-overflow"

    san-ut: sanitizer  # g++ sanitizerバイナリでの単体テスト
    	make O=$(SANITIZER_DIR) ut

    san-it: sanitizer  # g++ sanitizerバイナリでの統合テスト
    	make O=$(SANITIZER_DIR) it
```

## 難しいバグの対処 <a id="SS_15_8"></a>
一般に下記のような現象の原因特定は難しい。その再現性が悪いとなおさらそうなる。

* ハングアップ
* メモリ、ファイルハンドル等のリソースの枯渇
* 不正メモリアクセス
* 不正な命令の実行

本ドキュメントの提言に従ってソフトウェア開発を進めれば、
そのリスクを低く保てるが、それでもこのようなバグは発生する。

ハングアップについては、[ログの取得](debug.md#SS_15_6_1)、[デバッガの使用](debug.md#SS_15_1)
が有効なデバッグ方法となることが多い(もちろん組み込みの場合は、[モニター](debug.md#SS_15_6_2)が必要である)。
また、バージョンが特定できるのであればgitのdiff/bisect等(「[デバッガの使用](debug.md#SS_15_1)」参照)が役に立つ。

リソースの枯渇については、
scan-buildやcoverity等の静的解析ツール(「[潜在的バグの削減](debug.md#SS_15_7)」参照)を使うことで、
ピンポイントでリーク箇所を特定できることがあるため、
まずはこれらを使ってみることを推奨する。
これで発見できない場合、動的解析ツールの使用を検討するべきだろう。

恒久的には、 「[RAII(scoped guard)](cpp_idioms.md#SS_21_1_2)」で紹介したようなリソースの自動解放のパターンを使用し、
そもそもこのような問題が発生しないように改善するべきだろう。

バグの性質上、再現/回帰テストには長時間のアプリケーション動作が必要になることがある。
テスターにひたすらクリックさせるようなテストは非効率であるだけでなく、
人道的にも問題になるかもしれないため、[自動統合テストの実施](debug.md#SS_15_5)も必須になる。

不正メモリアクセス、不正な命令の実行に関しては、下記のようなメモリ破壊を疑うべきだろう。

* スタックの破壊
* 静的なオブジェクトの破壊
* newしたオブジェクトの破壊やダブルデリート

これらに関しても、上記したような静的/動的解析ツールの活用が有効になる場合が多い。
これで問題が発見できない場合、以下のような知識が必要になる。

* コンパイラのスタックの生成方法、CPUレジスタの使用方法、アセンブラ
* コンパイラに付属するバイナリツール
* CPU例外に対するランタイム系の処理方法

これらの知識はC++プログラマの基本スキルセットの一部だと思うが、
実際にはこれらの知識を持たないプログラマも少なくない。
そのようなプログラマにはこれを良い機会と捉え、新知識の習得に励んでほしいが、
目の前に迫った納期の前に、そのような悠長なことを言っていられないこともあるだろう。
そのような場合は、上級なプログラマに助成(「[助成の依頼](debug.md#SS_15_9)」参照)を頼むこと以外、
建設的なデバッグ方法はない
(やみくもにソースコードを眺めたり、
ログやprintfを仕込んでも、よほどの幸運でもない限りバグは見つからない)。

## 助成の依頼 <a id="SS_15_9"></a>

ここでのデバッグの「助成の依頼」とは以下のいずれかを指す。

* 動作説明を聞いてもらう
* 一緒にデバッグしてもらう

「動作説明を聞いてもらう」相手は、同プロジェクトのプログラマがベストであるが、
実際には難しいことが多い。こういった時(ほとんどの場合そうなるが)には、相手は誰でもいい。
それすらできない場合、ペットでも無生物でも良い。
他者に説明することで、自分の理解を確めることができ、
エアポケットに落ち込んでしまった見落としを発見できる可能性が高くなる。

「一緒にデバッグしてもらう」相手は、
「[難しいバグの対処](debug.md#SS_15_8)」で述べたような知識豊富なプログラマで無ければならない。
これができるか否かは、日頃の人付き合いに依存するが、知識豊富なプログラマの多くは、
人から頼られることを拒否しない(当然状況によるが、通常は喜んで手伝ってくれるはず)。

下記に筆者が他者から助成を頼まれた事例を取り上げる。
もしこのような現象を独力で解決できる自信がないのであれば、
まずは、思い切って依頼してみることだ。

### 現象1 - 不思議なハングアップ <a id="SS_15_9_1"></a>

この現象は、モニター機能を実装した組み込みソフトウェアのテストで起こった。
あるプログラマが、自分の書いた機能を長時間テストするために、
[Tera Term](https://ja.osdn.net/projects/ttssh2/)をターゲットボードに接続し、
そのソフトウェアに組み入れたテストをTera Termから起動して帰宅した。
翌日出社するとそのテストは途中でハングアップしてるように見える状態で止まっていた。
彼はなんとなく、Tera Termにリターンキーを入力した。すると、途中で止まっていたテストが再び走り出し、
数時間後に完了した。この状態でできることはほとんどないので、彼は何もなかったことにして、
その日の帰宅前にまた同様のテストを走らせた。次の朝、また同じことが起きたため、
この現象のデバッグに取り掛かろうとしたが、やり方が全く分からなかった。

この日の朝会はすでに終わっていたため、次の日の朝会でこの現象を報告し、助成を求めた。

この報告を聞いて難問題であることを確信した私は、すぐにでもデバッグを手伝いたかったが、
後2、3日かかるプログラミングの最中であったため、
彼に「その現象のTATがもっと短いテストパターンを探る」ように指示し、自分の作業をつづけた。
2日後、TATが30分までに短縮されたこの現象のデバッグに参加した。

このデバッグの難しさは、この現象が起こっている時にモニターから何か文字を打ち込むと、
ハングアップ状態が解けてしまうことであった。

現象からRTOSのバグであると推測して、jtagデバッガでRTOSのリソースを観察して、以下のことが分かった
(RTOSのリソースはより便利にモニターから見れたが、モニターを使うとこの現象が霧散してしまうため、
この機能は使えない)。

* カレントスレッドポインタがNULLである
* テストを実行するスレッドはレディーキューに繋がれている

RTOSの仕様では、

* 各スレッドには、その情報を保持するスレッド構造体が存在する
* カレントスレッドポインタは、実行中のスレッドのスレッド構造体を指す
* 実行可能(待っていたイベントが起こった等)なスレッドのスレッド構造体はレディーキューに繋がれる
* スレッドのディスパッチャは、RTOSのシステムコールか割り込みルーチンから実行される。
* ディスパッチャは、一旦カレントスレッドポインタをNULLにして、
  レディーキューに繋がれたスレッドの中で最高プライオリティを持つものをそこから取り出し、
  カレントスレッドポインタに代入した後、そのスレッドを走らせる
* カレントスレッドポインタがNULLの際に発生したチック割込みからは、
  ディスパッチャは呼び出されない(プリエンプション対象のスレッドがないため)。

となっていた
(このような詳細仕様は、通常ドキュメントには書かれていない。
また、書かれていてもそもそもRTOSを疑っているのだからその情報は信じられないため、
RTOSのコードハック以外の方法はない)。

以上から、

* 「カレントスレッドポインタがNULLである」ことは「現在実行中のスレッドは存在しない」
* 「レディーキューが空ではない」ことは「実行可能なスレッドが存在する」

を意味する。
このような中途半端な状態はディスパッチャ内でしか発生しないので、以下のことが分かったことになる。

* この現象はハングアップである
* カレントスレッドポインタは静的変数であるため、
  「[現象2 - グローバル変数の破壊](debug.md#SS_15_9_2)」のようなことがない限り、RTOSのバグである

「[現象2 - グローバル変数の破壊](debug.md#SS_15_9_2)」で書いたような方法により、
この現象が変数破壊でないことを確信した我々はさらにRTOSのコードハックを続けた。

ディスパッチャは、ディスパッチャ自身に割り込まれることがあるため、
カレントスレッドポインタやレディーキューにアクセスするときに割り込みを禁止し、
その処理の終了後に割り込みを許可する(これをクリティカルセクションの保護と言う)。
もしクリティカルセクションの保護をしなければこの現象が起こせることが分かったが、
クリティカルセクションを保護しているソースコード内のインラインアセンブラに問題がないことも分かり、
デバッグは行き詰った。
とはいえ、放置できる問題でもないため、コンパイル後のバイナリを逆アセンブルして、
動作を確かめることにした。これは苦痛に満ちた作業だが、他の方法を思いつかなかった。

そして、ようやく原因を特定できた。
「割り込み許可を行うインストラクション」と
「カレントスレッドポインタへNULLを代入するインストラクション」の順番が、
ソースコードに書かれている順番と逆になっており、
このためカレントスレッドポインタの操作が割り込みから保護されていなかったのだ。

結果はRTOSのバグではなく、
コンパイラのバグ(最適化に伴うインストラクションの不適切な入れ替え)であった。

一旦ソースコードにこのバグのワークアラウンドを入れ、コンパイラメーカーにこの現象を報告した。
2か月後にこのバグが修正されたコンパイラがリリースされたため、
ソースコードを元に戻し、この問題が再現しないことを確認してこの問題をクローズした。

### 現象2 - グローバル変数の破壊 <a id="SS_15_9_2"></a>
新人プログラマから以下のような現象の助言を求められた。

* 静的オブジェクトのメンバ変数一つが0を設定していないにもかかわらず、0になる。
* デバッガでアドレスが近い静的オブジェクトを見てみたが、他のオブジェクトには異常がないように見える。
* この問題は1日一回程度起こる(起こせる)

この現象を聞いて、まず疑ったのは「そのメンバ変数に0を代入していないつもりになっているだけで、
実際には0を代入している」ことであったため、ソースコードレビューをしたのだが、
問題は見つからなかった(ソースコードが汚いことは分かったが)。

次に行うべきは、「この現象が静的メモリの破壊である」ことの確定である。
壊されたと推定されたオブジェクトの前後に以下のようなオブジェクトを挿入して、
再現テストをすることにした。

```
    uint32_t pad0[] = { 0xdeadbeaf, 0xdeadbeaf, 0xdeadbeaf, ... };
    Collaps  collaps_obj;    // 破壊を疑っているオブジェクト。実際はシングルトンだった。
    uint32_t pad1[] = { 0xdeadbeaf, 0xdeadbeaf, 0xdeadbeaf, ... };
```

ここで注意すべきは、この変更で静的オブジェクトの配置が大きく変わっていないことを確かめることである。
linuxの場合、それにはnmコマンドが最適である。

参考のため、「[deps](deps.md#SS_17)」の実行形式バイナリにnmを適用した例を示す。

```
    > nm --demangle g++/deps

    000000000008b000 D __data_start
    00000000000085b0 t __do_global_dtors_aux
    0000000000089ff8 d __do_global_dtors_aux_fini_array_entry
    000000000008b008 D __dso_handle
                     U __dynamic_cast@@CXXABI_1.3
                     U __errno_location@@GLIBC_2.2.5
    0000000000089fa8 d __frame_dummy_init_array_entry
                     w __gmon_start__

    ...

                     U abort@@GLIBC_2.2.5
    000000000008b440 B optarg@@GLIBC_2.2.5
    000000000008b590 B optind@@GLIBC_2.2.5
    0000000000008570 t register_tm_clones
                     U strchr@@GLIBC_2.2.5
                     U strcmp@@GLIBC_2.2.5
                     U strtol@@GLIBC_2.2.5
                     U tolower@@GLIBC_2.2.5
```

nmにより挿入前後でpad0、pad1以外に並びが変わっていないことを確認した後、再現テストを行い
(ASLRを行うOS上のアプリケーションの場合、それを非活性化することも必要である）、
pad0の1ワードだけが0になっていることを確認できた。これでメモリ破壊であることが確定した
(さらに運のいいことに、0が書かれていたアドレスはpad0、pad1挿入前後で同じであった)。

もし、「[デバッガの使用](debug.md#SS_15_1)」で説明したようなことが可能ならば、
pod0への書き込みアドレスにライトトラップをかけて再現テストを行えば、
不正なデータの書き込み個所を特定できる。
この例の場合もデバッガを使用しバグを特定した。

デバッガが使用でいない場合でもやり方はいくつかあるが、最も単純なのはassert()を使う方法である。

このバグの場合、疑うべきは静的な配列のオーバーランである。
nmによりリストアップした静的な配列のライトアクセス箇所のインデックスに下記のようなコードを挿入して、
再現テストを行えばよい。

```cpp
    assert(0 <= index && index < array_length(global_array));
```

静的な配列へのライトアクセス箇所が多い場合、苦痛な作業となるが、
典型的なアンチパターンである静的な変数を多用した罰である考え、その苦痛を受け入れるべきだろう。


### 現象3 - プロセスのスローダウン <a id="SS_15_9_3"></a>
組み込みlinuxでの開発で起こったこの現象は、
usbストレージに大量のデータをコピーするプロセスがスローダウンするというものであった。
この問題を最初に聞いたのは、この対処に私が加わる3か月ほど前であった。
この時、難問であるとは思ったが、リリースまでまだ日数があったことと、担当が海外のチームだったため、
スルーした。

3ヶ月後、このチームサイトに出張した折、この問題がまだ解決できていないことを知った。
彼らがこの3ヵ月でこの問題に対して行ったことは、

* 1時間程度で再現させられるshellスクリプトを開発した(当初は数日に1回程度の頻度)
* 以下のことを発見した
    * この現象が起こった時、プロセスのnice値が最低プライオリティになっている
    * nice値をコマンドから変更しプライオリティを上げると問題はなくなる

* 最新のusbストレージのドライバを変更せずにそのまま使っており、
  ネットにもバグ等は報告れされいない

等であった。ここから推測されることは、

* usbストレージの最新の標準ドライバにこれほど高い再現率のバグがあるとは思えないため、
  この現象はusbとは関係ない
* nice値が不正になるということはチック生成と密接な関係がある

ということである。

チックの生成がどうなっているかを聞いたが誰も答えられなかったため、
ソースコードからそのドライバを探し出した。
subversionの履歴から、このコードはこのチームが一年ほど前に作ったことが分かったため、
担当者を呼び出しソースコードレビューを行い、以下のような怪しいコードを見つけた。

```cpp
    #define CHICK_REG_ADDR  0x00.....
    #define CHICK_REG_VALUE ((volatile ulonglong*)CHICK_REG_ADDR)

    ...

    ulonglong chick = CHICK_REG_VALUE;

    if(chick_previous > chick) { // chick_previous: 前回ロードしたchick
        ... // 桁上り対策
    }
```

この辺りのハードウェアの仕様は良く知らなかったが、
チックを作り出すチップとCPUはおそらく32ビットバスで繋がっていたはずである。
すぐにハードウェアの担当者に連絡を取り、32ビットバスであることを確認した。
(経験の長いエンジニアやチームリーダーはチームをまたがる情報に簡単にアクセスできるため、
彼らに助成を依頼すべき理由の一つになる)。

この開発で使用していたgccでのulonglongは64ビットであるため、

```cpp
    ulonglong chick = CHICK_REG_VALUE;
```

は以下のように段階的に読み込まれ、それぞれの値を合わせることでchickの値が生成される。

1. chick0 = (チックレジスタ63-32ビットの値)
2. chick1 = (チックレジスタ31-0ビットの値)
3. chick = (chick0 << 32) | chick1

チックレジスタの値が0x0000'0000'ffff'ffffのような場合、上記1でchick0には0がロードされるが、
上記2はそれより少し遅れて実行されるため桁上りが起こりほとんど0の値がchick1にロードされる。
上記3によりchickもほどんど0のような値になるため、前回ロードしたchickの値よりも小さい値となる。
これは長い時間が経過したことを表してしまうため、
現在実行中のプロセスがきわめて多くのCPUタイムを使用したことになり、
linuxのスケジューラはこのプロセスのプライオリティを最低に引き下げた。

これがこの問題のメカニズムだった。メカニズムさえわかってしまえば対処は簡単である。
担当者はすぐにコードを修正し、私がそれをレビューした後、
1時間でこの問題を再現させられるスクリプトによりテストを開始した。
2日後、問題がないことを確かめてこの問題をクローズした。


### 現象4 - バックトレースが見れない <a id="SS_15_9_4"></a>
関数Aが関数Bを呼び出した場合、Bの処理の完了後、
「AがBを呼び出したアドレスの次のアドレス」に戻る必要がある。
このアドレスを記録するためのレジスタをリターンアドレスレジスタと呼ぶことにする。
さらにBが関数Cを呼び出す場合、リターンアドレスレジスタは「BがCを呼び出したアドレスの次のアドレス」
で上書きされる。こうなるとBからAに戻れなくなるため、
BはCを呼び出す前にリターンアドレスレジスタをスタックにプッシュする。

デバッガのバックトレース機能を実行して表示される関数一覧は、
スタックに保存されたものを含むリターンアドレスレジスタから生成される。
従って、ソフトウェアがクラッシュした時、バックトレースが見れない原因は、

* スタックが破壊された
* スタックポインタが破壊された

のいずれかであると思って良いが、C/C++からスタックポインタを破壊することは難しいため、
OSの開発でない限り、スタック破壊を疑うべきである。

スタックが破壊された影響でバックトレースが見れない場合でも、
ほとんどの場合、多少は表示されるため、スタック破壊が発生する関数を絞り込める。
そのような関数群に下記のようなログを仕込むことでバグの個所をさらに絞り込める。

```cpp
    // どこかの.cpp内で以下の定義
    char const* global_last_func;

    // 絞り込んだ関数の先頭行
    extern char const* global_last_func;
    global_last_func = __func__;
```

該当する関数群が複数のスレッドから呼び出される場合、thread_localを使った工夫が必要になるが、
概ね同様のアプローチでバグが発生した関数を特定できる。

基本的なデバッグ方法であるため、わざわざ説明する必要はないかとも思ったが、
「バックトレースが見れないこと」と「その原因のほとんどがスタック破壊であること」
の論理的な繋がりを知らないプログラマが多いため、この節を書いた。


### 現象5 - newしたオブジェクトの破壊 <a id="SS_15_9_5"></a>
「開発中のソフトウェアが毎回違う場所でクラッシュする」現象について助力を求められたことがある。
クラッシュ時にデバッガからthisを表示すると毎回違うクラスであるという。
こういった場合、下記のようなコードが原因であると推測できる。

* newした配列やstd::vector等のオーバーラン
* delete済のポインタを使ったオブジェクトへの書き込み操作
* 二重delete

newした配列(「[メモリアロケーション](programming_convention.md#SS_3_5_6)」参照)やstd::vector等のオーバーランに関しては、
多くの場合、「[潜在的バグの削減](debug.md#SS_15_7)」で触れたようなコード解析で発見できるが、
このチームはすでにこの方法を試して、効果がないことを確認していた。
この現象につながるような静的解析での指摘もないことから、
再現したらメモリダンプを取るように指示して現場を後にした。

数日後、メモリダンプを解析するよう依頼を受けたため、
デバッガを使用して壊されたオブジェクトを観察し、オブジェクトの破壊を確認した。
thisをいくら見ても壊れていること以外何もわからないので、thisアドレス辺りを16進数表示してみた。

アドレスからその型を特定することは極めて難しいが、この場合は幸運だった。
16進数表示の中にヒープのアドレスらしきバイト列があったので、そこをさらに16進数表示して、
ASCII文字列のようなバイト列を発見した。このバイト列をソースコードから検索すると、
下記のようなコードを発見できた。

```cpp
    // f.cpp
    void f(char* s) {

        // sの後ろへの書き込み
        ...
    }

    // g.cpp
    g() {
        std::string s = "xxx";

        ...

        f((char*)s.c_str());

        ...
    }
```

最近CプログラマからC++プログラマに鞍替えした人が書いてしまったコードだそうだ
(このようなコードはCでもダメだが)。

### 現象6 - STLのバグ? <a id="SS_15_9_6"></a>
あるプロジェクトの朝会でのこと。
プログラマの一人がSTLのバグを発見したということで、他のメンバに注意を喚起した。
このプロジェクトで使用していたコンパイラは広く使われているものだったので、
そんなことはないだろうと思いつつ、念のために確認するとコードは下記のようなものだった。

```cpp
    //  example/etc/debug.cpp 13
    class Pred {  // 0を最大3個まで見つける
    public:
        Pred() noexcept {}
        bool operator()(int32_t i) noexcept
        {
            if (found_ > 2) {
                return false;
            }

            if (i == 0) {
                ++found_;
                return true;
            }

            return false;
        }

    private:
        size_t found_{0};
    };

    TEST(Debug, no_ref)
    {
        auto v = std::vector{0, 0, 0, 0, 1, 2, 3, 4, 5};

        v.erase(std::remove_if(v.begin(), v.end(), Pred{}), v.end());

    #if 0  // 本来ならば下記のテストがパスするはずだが。
        ASSERT_EQ((std::vector<int32_t>{0, 1, 2, 3, 4, 5}), v);
    #else
        ASSERT_EQ((std::vector<int32_t>{1, 2, 3, 4, 5}), v);
    #endif
    }
```

なるほど、初心者がよくやるミスである。

STLの関数は引数オブジェクトをコピーすることがあるため、下記のように書くべきだ。

```cpp
    //  example/etc/debug.cpp 49
    TEST(Debug, ref)
    {
        auto v    = std::vector{0, 0, 0, 0, 1, 2, 3, 4, 5};
        auto pred = Pred{};

        v.erase(std::remove_if(v.begin(), v.end(), std::ref(pred)), v.end());

        ASSERT_EQ((std::vector<int32_t>{0, 1, 2, 3, 4, 5}), v);
    }
```

この程度の述語であればラムダ式を使い下記のように書いても良いだろう。

```cpp
    //  example/etc/debug.cpp 61
    TEST(Debug, lambda)
    {
        auto v = std::vector{0, 0, 0, 0, 1, 2, 3, 4, 5};

        auto found = 0;
        auto it    = std::remove_if(v.begin(), v.end(), [&found](int32_t i) noexcept {
            if (found > 2) {
                return false;
            }

            if (i == 0) {
                ++found;
                return true;
            }

            return false;
        });
        v.erase(it, v.end());

        ASSERT_EQ((std::vector<int32_t>{0, 1, 2, 3, 4, 5}), v);
    }
```

このちょっとした事件で、このチームは、ありがちなSTLの誤用パターンを認知できた。
また、このバグはcopyコンストラクタを= deleteすれば防げたため、
改めて「[特殊メンバ関数](programming_convention.md#SS_3_2_4_1)」で指摘したことの重要性を確認することもできた。
と考えれば、この程度の知識で全員に注意を喚起した彼の勇気を称えるべきだろう。


### 現象7 - 解放後のrvalueへのアクセス <a id="SS_15_9_7"></a>
下記の関数gen_strは、

```cpp
    //  example/etc/debug.cpp 86

    std::string gen_str(std::string const& str)
    {
        return do_heavy_algorithm(str);  // 何らかの重い処理
    }
```

下記のように文字列リテラルから変換されたされたstd::stringオブジェクトである
[rvalue](core_lang_spec.md#SS_19_7_1_2)を引数に取ることができる。

```cpp
    //  example/etc/debug.cpp 96

    auto str = gen_str("haha");  // "haha"は、std::string{"haha"}に変換される
```

このテンポラリオブジェクトは、それをバインドしたリファレンスがスコープアウトするまで存在するため、
gen_strの仮引数リファレンスでバインドされたstd::stringオブジェクトであるrvalueは、
この関数がリターンするまで存在し続ける。
この仕様により、gen_str内ではこの仮引数に安全にアクセスすることができる。

この関数の処理が重すぎたため、下記のように並列化したが、これにより動作が不安定になった。

```cpp
    //  example/etc/debug.cpp 104

    std::future<std::string> gen_future(std::string const& str)
    {
        return std::async(std::launch::async, [&str] { return do_heavy_algorithm(str); });
    }
```

この関数は、下記のような呼び出しでクラッシュしてしまうことがある。

```cpp
    //  example/etc/debug.cpp 129

    auto f = gen_future("haha");
```

上記関数gen_futureの中で、

1. ラムダ式が生成され、そのラムダ式はrvalueのリファレンスをメンバとして保持する。
2. そのラムダ式を引数としたstd::asyncによりスレッドが生成される。
3. それを保持したstd::futureが生成され、関数がリターンする。

のようなことが行われ、この後、

4. gen_futureの呼び出しにより生成されたstd::stringオブジェクトであるrvalueは破棄される。

これはgen_futureを実行するコンテキスト上で行われるが、

5. それとは別のコンテキスト(スレッド)上でラムダ式が実行される。

上記4, 5のどちらが先に実行されるかは、その状況に依存するが、
4が5より先に実行された場合、このラムダ式は、すでに破棄されたrvalueへアクセスしてしまい、
クラッシュを引き起こす。

これの修正は、下記のようにラムダ式のリファレンスキャプチャをコピーキャプチャにすれば良い。

```cpp
    //  example/etc/debug.cpp 139

    std::future<std::string> gen_future(std::string const& str)
    {
        return std::async(std::launch::async, [str] { return do_heavy_algorithm(str); });
        //                                     ^^^ コピーキャプチャ
    }
```

gen_futureと同様の仕様を持つ以下の関数

```cpp
    //  example/etc/debug.cpp 166

    std::thread gen_thread_lambda(std::string const& str, std::string& str_out)  // str_outに結果出力
    {
        return std::thread{[&str, &str_out] { str_out = do_heavy_algorithm(str); }};
    }
```

にも、下記のように呼び出すことで、ほぼ同様の問題が発生する。

```cpp
    //  example/etc/debug.cpp 193

    auto str_out = std::string{};
    auto t       = gen_thread_lambda("haha", str_out);

    t.join();
```

これの修正も、下記のようにラムダ式のリファレンスキャプチャをコピーキャプチャにすれば良い。

```cpp
    //  example/etc/debug.cpp 206

    std::thread gen_thread_lambda(std::string const& str, std::string& str_out)  // str_outに結果出力
    {
        return std::thread{[str, &str_out] { str_out = do_heavy_algorithm(str); }};
        //                  ^^^ コピーキャプチャ
    }
```

gen_thread_lambdaのC++03のスタイルである以下の関数

```cpp
    //  example/etc/debug.cpp 236

    void thread_entry(std::string const& str, std::string& str_out) { str_out = do_heavy_algorithm(str); }

    std::thread gen_thread_func(std::string const& str, std::string& str_out)  // str_outに結果出力
    {
        return std::thread{thread_entry, std::ref(str), std::ref(str_out)};
    }
```

にも、やはり同様の問題が発生する。

上記修正とほぼ同様に、下記のようにリファレンス渡しをコピー渡しにすれば修正できる。

```cpp
    //  example/etc/debug.cpp 275

    void thread_entry(std::string str, std::string& str_out)
    //                            ^^^ コピー渡し
    {
        str_out = do_heavy_algorithm(str);
    }

    std::thread gen_thread_func(std::string const& str, std::string& str_out)  // str_outに結果出力
    {
        return std::thread{thread_entry, str, std::ref(str_out)};
        //                               ^^^ コピー渡し
    }
```

以上で見てきたように、C++ではリファレンスがわかりづらいバグを生み出してしまうことが良くある。
リファレンスを使わなければこのような問題を避けることができるが、実行速度が遅くなり、
C++を使用する意味がなくなる。

従って、C++で効率よくプログラミングするためには、
このような微妙な問題を的確に記述できなければならない。

## まとめ <a id="SS_15_10"></a>
おぞましいことだが、修正の難しいバグをその場しのぎ手法(グローバル変数を使う等)で回避したり、
周知されていない再現性の低いバグをなかったことにする等の、
プロとしてあるまじき行為への誘惑にかられることがある。
ガッツはそういった悪魔のささやきにあらがうための重要な要素だが、
そのような精神論のみらなず、このドキュメントで示したような手法を自在に使えるようになることが、
おぞましい行為から自身を守る手段となる。

一旦ダークサイドに落ちてしまえば、それは習慣となり、そこでプログラマとしての成長は終わる。
そうならないために学習あるのみである。


