<!-- ./md/dev_tools.md -->
# 開発ツール <a id="SS_16"></a>
この章で触れる開発ツールとは、以下の3つである。

* コンパイラ
* デバッガ
* エディタ/IDE

開発ツールはプログラマの生産性に大きく影響を及ぼすため、
ソフトウェア開発プロジェクトにとって極めて重要なファクターである。

___
__この章の構成__

&emsp;&emsp; [コンパイラ](dev_tools.md#SS_16_1)  
&emsp;&emsp; [デバッガ](dev_tools.md#SS_16_2)  
&emsp;&emsp;&emsp; [printfデバッグ](dev_tools.md#SS_16_2_1)  

&emsp;&emsp; [エディタ/IDE](dev_tools.md#SS_16_3)  
&emsp;&emsp; [筆者の開発ツール環境](dev_tools.md#SS_16_4)  
&emsp;&emsp;&emsp; [vim/neovimの設定](dev_tools.md#SS_16_4_1)  

&emsp;&emsp; [費用](dev_tools.md#SS_16_5)  
  
  

## コンパイラ <a id="SS_16_1"></a>
コンパイラの要件とは、以下のようなものである。

* C++11以上の規約に準拠している。
* バグが少なく、その修正も早い。
* 静的、動的検査機能が豊富である(「[コード解析](code_analysis.md#SS_4)」参照)。
    * 静的検査とはコンパイル時の警告や、clangのscan-buildのようなものを指す。
    * 動的検査とはg++/clang++に置けるsanitizerのようなものを指す。
* コンパイルが速い。
* カバレッジの計測ができる(「[単体テストのサポートツール](process_and_infra.md#SS_11_2_1_4)」参照)。

当然の事柄のように思えるかもしれないが、ある大手半導体メーカ純正のコンパイラ(IDE)は、
言語規約に準拠しておらず、下記のようなコードが警告すらなくコンパイルできた。

```cpp
    int f(char const* arg)
    {
        char* arg_local = arg;  // <- これがコンパイルできてしまう。

        ...
    }
```

さらに驚くことに、組み込みソフトウェア専用のコンパイラであるにもかかわらず、
上記constをvolatileとしても同様にコンパイルできた。

これらバグは指摘しても修正されず、少なくとも数年にわたって放置された。
筆者がこのコンパイラを使う機会をなくしたため、修正されたかどうかは未確認である。
プログラマのちょっとしたミスを指摘できない、このようなコンパイラを使ってはならない。

私がお勧めするのは以下のコンパイラである。

* gcc/g++
* clang/clang++
* Visual Studioコンパイラ(少々納得できない仕様もあるが)

他にもたくさんあるはずである。
コンパイラの選定は重要な事項と心得て慎重に選んでほしい。

なお、windowsアプリケーションの開発にもclang/clang++は適用でき、
その場合、sanitizerを使用できる。Visual Studio 19でもaddress sanitizerは使用できるようなので、
windowsアプリケーションの開発にはsanitizerを用いることことを強く推奨する。

## デバッガ <a id="SS_16_2"></a>
当然ながらデバッガは下記を選択するのが良いだろう。

* gcc/g++に対してはgdb
* clang/clang++に対してはlldb
* Visual Studioではそれに同梱されてるもの

組み込みソフトウェアに関しては少々事情が異なる。
本ドキュメントでは、組み込みソフトウェアに関して、
PC上のコンパイラを使用した単体テストを推奨している(「[単体テストのサポートツール](process_and_infra.md#SS_11_2_1_4)」参照)。
これに従うのであれば、単体テストのコンパイル、デバッグには、
通常のアプリケーション開発と同様に上記の3つの組み合わせのいずれかを使うのが良いだろう。

組み込みソフトウェアのターゲットのデバッグに関しては、gdb等のリモート機能を使える場合もあるが、
多くの場合jtagデバッガを使う必要がある。専用のハードウェアが必要なため多少高価になるが、
工数の方がよほど高価であることを忘れてはならない
(ただし、半導体メーカ純正品よりもサードパーティ品の方が、数分の一の費用である場合があるので注意)。

### printfデバッグ <a id="SS_16_2_1"></a>
printfデバッグとは、printf()やstd::coutを使ったデバッグ手法のことである。
これ自体はそれなりに有効な手段であり、完全に否定はできないが、
これ以外にデバッグ手法を知らないプログラマに出会うと、
現在に蘇ったネアンデルタールに見えてしまう。
ホモ・サピエンスの名に恥じないプログラマになるために最新のデバッガを導入しよう。
導入でロスした時間はデバッグの効率化でお釣りが来る。

## エディタ/IDE <a id="SS_16_3"></a>
エディタ/IDEの良し悪しについて語ることには、宗教論争ような危険が伴う。
「宗論はどちら負けても釈迦の恥」というように、不毛な戦いは避けるべきであるが、
とはいえ、各プログラマにその選択の全権を与えるのも問題である。

開発プロジェクトでは、下記の要件を満たすようなエディタ/IDEを使い、
それらの設定ファイル等もバージョン管理システムで管理し、
同一エディタ/IDEを使うメンバが共有できるようにするべきである。

以下にエディタ/IDEに求められる要件を上げる。

* 他の開発ツールとの連動
    * ビルドができる(「[アーキテクチャとファイル構造](architecture.md#SS_10_3)」参照)。
    * デバッガを起動し、エディタ/IDEソースコード画面上でのデバッグができる。
    * バージョン管理システムとの連携ができる。
    * 単体テストを実行できる。
    * エディタ/IDE画面上でshell/ターミナルを使用できる。
    * OSの任意のコマンドを実行できる。

* 実行環境等
    * windows/linuxを含む複数のOSで動作する。
    * 動作が軽い。
    * プラグイン等の拡張機能をサポートしている。また、追加費用なしで使えるプラグインが豊富である。
    * 多言語対応、UTF-8対応している。

* プログラム編集
    * コード補完機能やタグジャンプができる。
    * ショートカットキー等が豊富にあり、習熟すれば効率化できる。
      また、マウスを使わなくても、ほぼすべての機能が使える。
    * 多プログラミング言語対応(カラーリング等)をしている。
    * UMLやマークダウン等の設計ドキュメントの編集もサポートしている。

* その他
    * 世界的に評価が高い、もしくは評価がある。
    * 盛んに開発が行われている。
    * ライセンス費がフリーか、安価である。
    * help機能、ネットドキュメント、書籍が充実している。
    * 設定ファイルの管理が簡単である。windows版のエディタ/IDEによっては、
        * 設定をレジストリに保存しエクスポート機能もないため、
          環境の再現や共有に時間がかかるものがある。
        * 設定ファイルから絶対パスの記述を排除できないものがある。
          このようなIDEを使用すると、作業ディレクトリが固定化されてしまう。

多くの要件を上げたが、このような条件をほぼ満たすエディタ/IDEは少なくない。
例を上げる。

* Visual Studio
* Visual Studio Code
* Eclipse
* Sublime Text
* Atom
* vim/neovim
* emacs

少なく見積もってもこれだけの選択肢があるのであるから、
間違っても日本国内でのみで流通しているようなローカルなエディタ/IDEを使ってはならない。

## 筆者の開発ツール環境 <a id="SS_16_4"></a>
筆者は、windows、cygwin、linuxでソフトウェアを開発する必要があるため、一般のプログラマと比べ、
少々事情は異なると思うが、参考のためC++での開発ツールを紹介する。

* windowsアプリケーションの開発にはVisual Studioを使用している。
* Macでの本格的な開発経験がないので推奨できる開発ツールはないが、おそらくlinuxと同じで問題ない。
* linuuxアプリケーションの開発には下記を使用している。
    * コンパイラ
        * gcc/g++もしくはclang/clang++
    * デバッガ
        * gdbもしくはlldb
    * エディタ/IDE
        * Visual Studio Code
        * vim/neovim

* 組み込みアプリケーションの開発では下記のようにしている。
    * 単体テスト(「[単体テストのサポートツール](process_and_infra.md#SS_11_2_1_4)」参照)に関してはlinuxと同じ。
    * ターゲットは様々であるためクロスコンパイラの推奨は難しいが、
      オプションや警告機能のレベルがgcc/g++と近いものを選ぶと良い。
    * デバッガも同様にこれと決まったものはないが、jtagデバッガは必須である。

* このドキュメントの作成にはコードも合わせて下記を使用している
    * g++/clang++
    * gdb
    * vim/neovim

### vim/neovimの設定 <a id="SS_16_4_1"></a>
参考のため、このドキュメントを作成するために筆者が使用しているvim/neovimの設定やプラグイン、
その管理方法を紹介する。
vim/neovimの設定について興味がなければ、「[費用](dev_tools.md#SS_16_5)」まで飛んでほしい。

#### 設定ファイルと管理 <a id="SS_16_4_1_1"></a>
このドキュメント作成時、cygwinパッケージにはneovimは存在せず、
優れたコード補完機能はneovimでなければ動作しない。
このドキュメントのコードはcygwin、linux両方でビルドでき、
少なくともg++でのバイナリはそれぞれの環境で正常動作できるようにしなければならない。
開発とは関係ないが、windows上での複雑なテキスト編集にはwindows版gvim(gui vim)を使用したい。
また、「[DRYの原則](software_practice.md#SS_2_1)」の通り、それぞれの環境でそれぞれの設定をしたくない。

これからの条件を満たすためのvim/neovimの設定ファイルは、

* cygwin上のvim
* windows上のgvim
* linux(実際にはWSL ubuntu)上のneovim

を正しく初期化できる必要がある。
また、これらが別々に進化しないように一つのリポジトリで管理できるのが良い。
筆者の場合は、クラウド上のgitでvim_configリポジトリとして管理している。

以下、順を追ってvim_configリポジトリとして管理しているファイルについて簡単に説明する。
詳細については「[vim](sample_code.md#SS_24_1)」を参照してほしい。

#### ドキュメント <a id="SS_16_4_1_2"></a>
|ファイル                              |機能                              |
|:-------------------------------------|:---------------------------------|
|[vim_config/README.md](sample_code.md#SS_24_1_1)         |リポジトリの説明、インストール手順|
|[vim_config/nvim/cheatsheet.md](sample_code.md#SS_24_1_12)|自分用ヘルプやtodo                |


#### 初期化 <a id="SS_16_4_1_3"></a>
|ファイル                            |機能                |
|:-----------------------------------|:-------------------|
|[vim_config/nvim/init.vim](sample_code.md#SS_24_1_16)   |nvim初期化          |
|[vim_config/nvim/org.vim](sample_code.md#SS_24_1_17)    |基本設定            |
|[vim_config/nvim/package.vim](sample_code.md#SS_24_1_18)|外部パッケージ初期化|
|[vim_config/vim/gvimrc](sample_code.md#SS_24_1_36)      |gvim初期化          |
|[vim_config/vim/vimrc](sample_code.md#SS_24_1_37)       |vim初期化           |
|[vim_config/vim.sh](sample_code.md#SS_24_1_35)          |エイリアス等の設定  |
|[vim_config/inputrc](sample_code.md#SS_24_1_2)         |gdb設定             |


#### 独自スクリプト <a id="SS_16_4_1_4"></a>
##### c/c++編集 <a id="SS_16_4_1_4_1"></a>

|ファイル                                       |機能                            |
|:----------------------------------------------|:-------------------------------|
|[vim_config/nvim/autoload/next_file.vim](sample_code.md#SS_24_1_9)|xxx.cpp xxx.h xxx_ut.cpp切り替え|
|[vim_config/nvim/plugin/next_file.vim](sample_code.md#SS_24_1_29)  |同上                            |
|[vim_config/nvim/plugin/ctags_ext.vim](sample_code.md#SS_24_1_22)  |ctags作成                       |
|[vim_config/nvim/plugin/dev_env.vim](sample_code.md#SS_24_1_23)    |開発用画面設定                  |
|[vim_config/nvim/autoload/termdbg.vim](sample_code.md#SS_24_1_11)  |gdb連動                         |
|[vim_config/nvim/plugin/termdbg.vim](sample_code.md#SS_24_1_33)    |同上                            |


##### bash起動 <a id="SS_16_4_1_4_2"></a>

|ファイル                                  |機能         |
|:-----------------------------------------|:------------|
|[vim_config/nvim/autoload/term.vim](sample_code.md#SS_24_1_10)|:terminal設定|
|[vim_config/nvim/plugin/term.vim](sample_code.md#SS_24_1_32)  |同上         |

##### git連動 <a id="SS_16_4_1_4_3"></a>

|ファイル                                         |機能                   |
|:------------------------------------------------|:----------------------|
|[vim_config/nvim/autoload/git_diff.vim](sample_code.md#SS_24_1_5)   |git diffをvimdiffで表示|
|[vim_config/nvim/plugin/git_diff.vim](sample_code.md#SS_24_1_24)     |同上                   |
|[vim_config/nvim/autoload/git_session.vim](sample_code.md#SS_24_1_6)|mksessionやpath設定    |
|[vim_config/nvim/plugin/git_session.vim](sample_code.md#SS_24_1_25)  |同上                   |

##### ファイルタイプ設定 <a id="SS_16_4_1_4_4"></a>

|ファイル                                    |機能                        |
|:-------------------------------------------|:---------------------------|
|[vim_config/nvim/ftplugin/c.vim](sample_code.md#SS_24_1_13)     |c/c++ファイルのインデント等 |
|[vim_config/nvim/ftplugin/python.vim](sample_code.md#SS_24_1_14)|pythonファイルのインデント等|
|[vim_config/nvim/ftplugin/ruby.vim](sample_code.md#SS_24_1_15)  |rubyファイルのインデント等  |

##### その他 <a id="SS_16_4_1_4_5"></a>

|ファイル                                             |機能                      |
|:----------------------------------------------------|:-------------------------|
|[vim_config/nvim/autoload/buffers.vim](sample_code.md#SS_24_1_3)        |バッファエクスプロー      |
|[vim_config/nvim/plugin/buffers.vim](sample_code.md#SS_24_1_19)          |同上                      |
|[vim_config/nvim/autoload/grep.vim](sample_code.md#SS_24_1_7)           |grep                      |
|[vim_config/nvim/plugin/grep.vim](sample_code.md#SS_24_1_26)             |同上                      |
|[vim_config/nvim/autoload/cd.vim](sample_code.md#SS_24_1_4)             |カレントディレクトリの変更|
|[vim_config/nvim/plugin/cd.vim](sample_code.md#SS_24_1_20)               |同上                      |
|[vim_config/nvim/autoload/multi_hl.vim](sample_code.md#SS_24_1_8)       |マルチハイライト          |
|[vim_config/nvim/plugin/multi_hl.vim](sample_code.md#SS_24_1_28)         |同上                      |
|[vim_config/nvim/plugin/clear_undo.vim](sample_code.md#SS_24_1_21)       |undo履歴クリア            |
|[vim_config/nvim/plugin/keybind.vim](sample_code.md#SS_24_1_27)          |キーバインドの設定        |
|[vim_config/nvim/plugin/scratch.vim](sample_code.md#SS_24_1_31)          |スクラッチウインド        |
|[vim_config/nvim/plugin/path_set.vim](sample_code.md#SS_24_1_30)         |pathの追加                |
|[vim_config/nvim/rplugin/python3/next_file.py](sample_code.md#SS_24_1_34)|pythonでのプラグイン例    |

#### 外部パッケージ <a id="SS_16_4_1_5"></a>

|パッケージ              |機能              |
|:-----------------------|:-----------------|
|Shougo/dein.vim         |外部パッケージ管理|
|roxma/nvim-yarp         |補完              |
|roxma/vim-hug-neovim-rpc|補完              |
|Shougo/deoplete.nvim    |補完              |
|zchee/deoplete-clang    |C++補完           |
|Shougo/neoinclude.vim   |補完              |
|tpope/vim-fugitive      |Git連動           |
|reireias/vim-cheatsheet |自分用ヘルプ      |
|mattn/vim-maketable     |MDテーブル        |
|aklt/plantuml-syntax    |Plant Umlサポート |


## 費用 <a id="SS_16_5"></a>
コンパイラ、デバッガ、エディタ/IDEの費用は、
ライセンス形態によっては総額が単価×プログラマの人数となるため、
プロジェクトやそのプロジェクトを所有する事業体にとっては重荷になる。

それでも人件費に比べれば一桁以上安いはずなので、
金を出し惜しんでプログラマの生産性を落としては本末転倒であるが、
その金を管理する人々にはそのことが理解できないため、予算申請が却下されることは珍しくない。

そうならないためには、プログラマといえども会計の知識が必要である
(とはいえ、基本的知識のみで十分である)。

一般にプロジェクトに必要なお金は2つに分けられる。

* 経費
* 固定資産の購入費

プロジェクトの経費には、

* 人件費
* 少額物品(10万円未満)の購入費
* 固定資産の償却費

等が含まれる。固定資産の償却費とは、長く使用するもの(通常は高額)を年割で費用化したものである。
これだけでは、初見の人には何のことか全くわからないので例を上げる。

あるプロジェクトのために固定資産の購入費を使用し100万円のコンパイラを買ったとする。
話を単純にするため、会社では定額償却するとした場合(実際には定額と定率がある)、
コンパイラの耐用年数は5年(税法で決まっている)であるため、100万円÷5年で、
一年間20万円の費用が掛かると考える。これが固定資産の償却費である。
最初に100万円払ったのにまた払うのかと思うかもしれないが、
最初の100万円は同じ価値の固定資産(コンパイラ)になっただけであるため、
経費会計上、費用は掛かっていないと考えることになっているので矛盾はない。

実際にはコンパイラの代金100万円はこの会社からコンパイラ販売会社に支払われるため、
会社が持っているキャッシュは100万円減る。
が、上記したようにプロジェクトの初年度には20万円しか使っていないことになる
(キャッシュが無くなれば会社は倒産するのだから、これが黒字倒産の仕組みである)。

このような仕組みがあるため、キャッシュが少ない会社では固定資産の申請は却下されやすい
(キャッシュリッチな会社でも上場している場合は、固定資産の増加を嫌う傾向がある)。

一方で、このコンパイラをサブスクリプションで月額16,667円の契約した場合(5年で100万円)、
この費用はプロジェクトの経費に組み込まれる。

ここまででツール購入の会計知識は十分である。

ここで考えてほしいのは、一括購入100万円とサブスク16,667円/月のどちらが予算申請を通りやすいのか、
ということである。通常の会社では100万円の決済は課長レベルではできないが、16,667円/月の決済ならば、
チームリーダーレベルでできるはずである。
自分たちが使うツールはサブスクができないとの意見もあるだろうが、
リース会社を通すことでほとんどのツールはサブスク化可能である
(この場合少し費用が高くなるが、万事うまく行く案等そうそうない)。

費用レスで十分な機能をもつツールが多いのだから、なるべくそれらを使うべきだと思うが、
どうしても必要な高額ツールの購入には、こういった方法を駆使してプログラマの生産性向上を図ってほしい。


