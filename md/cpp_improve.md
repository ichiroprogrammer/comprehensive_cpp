# C++の進化と主な変更点
C++は、時代と共に進化を続け、その表現力と効率性が大きく向上してきた。
この章では、C++11以降にて導入された主要な機能や変更点を概観し、各バージョンがもたらした技術的な進展を示す。

___

__この章の構成__

<!-- index 1-3 -->

## C++11の主な新規機能
### 一般機能

|機能                                                          |説明                                                                        |
|:-------------------------------------------------------------|:---------------------------------------------------------------------------|
|[型推論](---)(auto)                                           |変数や、式の型の推論                                                        |
|[decltype](---)                                               |式の型を取得                                                                |
|[構文|範囲for文](---)                                         |インデックス変数なしのfor文                                                 |
|[オブジェクトと生成|初期化子リストコンストラクタ](---)        |vector<int> v = {1, 2, 3}; など。                                           |
|[一様初期化](---)                                          　 |コンストラクタの呼び出しを、波カッコで行う。|vector<int> v{1, 2, 3};        |
|[expressionと値カテゴリ|rvalue](---)/[moveセマンティクス](---)|[オブジェクトと生成|オブジェクトの所有権](---)の移転、高速化。              |
|[構文|ラムダ式](---)                                          |関数オブジェクトをその場に書く                                              |
|noexcept                                                      |関数の例外指定、例外を投げる可能性のある式かbool値を返す演算子              |
|constexpr                                                     |定数式の宣言。「[const/constexprインスタンス](---)」参照                    |
|nullptr                                                       |ヌルポインタを表すポインタ[リテラル](---)                                   |
|インライン名前空間                                            |ネストした名前空間に透過的にアクセスする。「[スコープ|名前空間](---)」参照  |
|ユーザー定義リテラル                                          |[ユーザ定義リテラル演算子]により定義されたリテラル                          |


### 型に対する機能

|機能                                                          |説明                                                                      |
|:-------------------------------------------------------------|:-------------------------------------------------------------------------|
|[オブジェクトと生成|特殊メンバ関数](---)のdefault/delete 宣言|自動定義される特殊関数の制御                                               |
|[委譲コンストラクタ](---)                                    |コンストラクタから他のコンストラクタに処理を委譲する                       |
|[NSDMI](---)                                                 |非staticメンバ変数の宣言と同時に初期値指定する                             |
|[継承コンストラクタ](---)                                    |基底クラスのコンストラクタの継承                                           |
|virtual関数のoverride/final宣言                              |「[オーバーライド](---)」参照                                              |
|変換演算子のオーバーロードのexplicit宣言                     |「 [演算子オーバーロード](---)」参照                                       |
|friend 宣言の対象を拡張                                      |「[StaticStringの開発](---)」参照                                          |
|メンバ関数の[rvalue修飾](---)/[lvalue修飾](---)              |オブジェクトの[expressionと値カテゴリ](---)での呼び出し可能であることの指定|
|スコープドenum                                               |スコープを持ち、型付の強いenum。「[enum](---)」参照                        |
|unionの保持できるオブジェクトの拡張                          |unionでクラスオブジェクトをもつことを許                                    |

### テンプレートに対する機能

|機能                                |説明                                                                                       |
|:-----------------------------------|:------------------------------------------------------------------------------------------|
|テンプレート引数の指定に>>の許可    |vector<list<int>> のような記述の許可。「[|テンプレートメタプログラミング](---)」参照       |
|[extern template](---)              |テンプレートのインスタンス化の抑止                                                         |
|エイリアステンプレート              |エイリアスをテンプレート化。「[is_same_templ](---)」参照                             |
|[パラメータパック](---)             |任意の数のテンプレートパラメータを受け取れるようにする                                     |
|テンプレートパラメータ型の制限の緩和|ローカル型と無名型を、テンプレート引数として使用することを許可                             |
|任意の式による[SFINAE](---)         |特定の式が[ill-formed](---)か否かで、その関数をオーバーロード解決に含めるかどうかを決定する|
|テンプレートのエクスポート機能      |削除                                                                                       |


### スレッドに関する機能

|機能                                                    |説明                                                                                |
|:-------------------------------------------------------|:-----------------------------------------------------------------------------------|
|スレッドローカルストレージ                              |スレッドごとに異なる静的記憶域に保持される変数                                      |
|ブロックスコープのstatic変数初期化のスレッドセーフ化    |関数ローカルで定義したstatic変数の初期化をスレッドセーフに。「[Singleton](---)」参照|


### その他のユーティリティ

|機能                            |説明                                                                             |
|:-------------------------------|:--------------------------------------------------------------------------------|
|戻り値の型を後置する関数宣言構文|「[戻り値型](---)」参照                                                          |
|コンパイル時アサート            |コンパイル時に条件式が真であることをassertする。「[assertion](---)」参照         |
|[生文字列リテラル](---)         |文字列リテラルにRプレフィックスを付けることで、エスケープシーケンスを無視する。  |
|char16_tとchar32_t              |UTF-16とUTF-32の文字型                                                           |
|UTF-8文字列リテラル             |char の文字列をUTF-8エンコーディングするプレフィックス                           |
|属性構文                        |[[attr]]構文による属性指定。[[noreturn]]など。「[return文](---)」参照            |
|alignas                         |アライメントを指定する。「[固定長メモリプール](---)」参照                        |
|alignof                         |アライメントを取得する。「[固定長メモリプール](---)」参照                        |


### stdの変更、追加
#### stdコンテナ
コンテナ全般が[moveセマンティクス](---)に対応したため、
テンプレートのパラメータTが、コピー構築可能(is_copy_constructible\<T\>== true)な型だけでなく、
ムーブ構築(is_move_constructible)のみ可能な型も受け付けるられるようになった。
push_back()やinsert()等の要素追加のためのメンバ関数が、
新たな要素のコピーだけでなく、emplace() 、emplace_back() 、emplace_front()のような名称のメンバ関数は、
[expressionと値カテゴリ|rvalue](---)オブジェクトも受け取れて、
move挿入ができるようになった(「[その他のテンプレートテクニック](---)」参照)。

|機能                            |説明                                                                                |
|:-------------------------------|:-----------------------------------------------------------------------------------|
|std::array                      |このコンテナは固定長配列クラスを表す「[型とインスタンス|配列](---)」参照)。         |
|[std::forward_list](---)        |このは単方向リンクリストの実装である。                                              |
|[std::unordered_map](---)       |同一キーの要素を複数格納しない、格納順が規定されていない連想配列の実装であるである。|
|[std::unordered_set](---)       |同一キーの要素を複数格納できず、格納順が規定されていないコンテナである。            |
|[std::type_index](---)          |型情報型を連想コンテナのキーとして使用するためのクラス。                            |

#### C++11/stdコンテナの使用例
##### std::forward_list

```cpp
    // @@@ example/cpp_improve/cpp11_ut.cpp #0:0 begin -1
```

##### std::unordered_map

```cpp
    // @@@ example/cpp_improve/cpp11_ut.cpp #0:1 begin -1
```

##### std::unordered_set

```cpp
    // @@@ example/cpp_improve/cpp11_ut.cpp #0:2 begin -1
```

##### std::type_index

```cpp
    // @@@ example/cpp_improve/cpp11_ut.cpp #0:3 begin -1
```

## C++14の主な新規機能

|機能                                                |説明                                                                             |
|:---------------------------------------------------|:--------------------------------------------------------------------------------|
|2進数[リテラル](---)                                |2進数を表す0bもしくは0Bプレフィックスを付けた数値リテラルの記述を可能に          |
|[通常関数の戻り値型推論](---)                       |関数の戻り値型をauto にすることで、[return文](---)から戻り値の型を推論させる     |
|decltype(auto)                                      |decltypeの規則による変数の[型推論](---)                                          |
|後置戻り値型をauto                                  |戻り値の型を後置する関数宣言構文とラムダ式の戻り値型にauto を使用できるようにする|
|[C++その他|ラムダ式](---)の初期化キャプチャ         |キャプチャに代入構文を導入し、一つの変数に複数のキャプチャ方法を指定可能にする   |
|[ジェネリックラムダ](---)                           |ラムダ式のパラメータを auto にすることで、ジェネリックな関数呼び出しに           |
|[変数テンプレート](---)                             |変数定義時のテンプレート指定を可能に                                             |
|constexpr関数内での条件分岐とループの文を許可       |[constexpr if文](---)                                                            |
|structの[NSDMI](---)の対応                          |                                                                                 |
|structのネストする初期化における波カッコ省略を許可  |一様初期化と初期化子リストを組み合わせた際、二重に波カッコが不要に               |
|[[deprecated]] 属性                                 |非推奨の機能であることを示す属性                                                 |                                                
|数値[リテラル](---)の桁区切り文字                   |シングルクォーテーションで数値リテラルを桁区切りする                             |
|サイズ付きデアロケーション                          |[グローバルnew/deleteのオーバーロードの実装](---)                                |
|[heap allocation elision](---)                      |動的メモリ確保の省略(heap allocation elision)の許可                              |

### C++14新機能例
#### 通常関数の戻り値型推論

```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #0:1 begin -1
```

#### 後置戻り値型をauto

```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #1:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #1:1 begin -1
```

#### 変数テンプレート

```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #2:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #2:1 begin -1
```

### stdの変更、追加

|機能                                   |説明                                                                             |
|:--------------------------------------|:---------------------------------------------------------|
|std::make_unique<>()                   |「[演算子|メモリアロケーション](---)」参照                |
|std::exchange()                        |二つの値を入れ替える。「[Copy-And-Swap](---)」参照        |
|[std::integer_sequence](---)           |コンパイル時整数シーケンス                                |
|[std::get()のオーバーロード](---)を追加|タプルを型の集合と見なし、型を指定して対応する値を取得する|
|\<type_traits>                         |xxx_t、xxx_vなどのエイリアステンプレート、定数テンプレート|
|[std::stringリテラル演算子](---)       |「[ユーザ定義リテラル演算子](---)」参照                   |
|[std::chronoのリテラル](---)           |                                                          |
|[std::complexリテラル](---)            |                                                          |

#### C++14/stdの追加使用例
##### std::integer_sequence

```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #3:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #3:1 begin -1
```

##### std::get()のオーバーロード

```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #4:0 begin -1
```

##### std::stringリテラル演算子

```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #5:0 begin -1
```

##### std::chronoのリテラル

```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #6:0 begin -1
```

##### std::complexリテラル

```cpp
    // @@@ example/cpp_improve/cpp14_ut.cpp #7:0 begin -1
```


## C++17の主な新規機能
### 新機能、規制緩和

|機能                                         |説明                                                                                               |
|:--------------------------------------------|:--------------------------------------------------------------------------------------------------|
|16進浮動小数点数リテラル                     |十六進数表記で浮動小数点数リテラルを記述できるようにする                                           |
|インライン変数                               |inline 指定をすることで翻訳単位を跨いでひとつのオブジェクトになる変数を定義する                    |
|構造化束縛                                   |「[戻り値型](---)></a>」参照                                                                       |
|[単一要素の波カッコ初期化を非配列とする](---)|リストによる直接初期化の型推論の規則が変更された                                                   |
|[[maybe_unused]]属性                         |使用しない可能性のある変数に対する警告を抑制                                                       |
|[[nodiscard]]属性                            |関数の戻り値を捨ててはならないことを指定。「[グローバルnew/deleteのオーバーロードの実装](---)」参照|
|[RVO(Return Value Optimization)](---)        |右辺値を変数の初期化のために使用する場合、コピーもムーブも省略することを保証                       |
|[厳密な式の評価順](https://cpprefjp.github.io/lang/cpp17/expression_evaluation_order.html)|C++14まで未規定であった部分式の評価順序を規定         |
|[enum class変数の初期値のルール変更](---)    |std::byteの初期化を簡略化できる                                                                    |
|[newのアライメント指定](---)                 |                                                                                                   |
|[if文とswitch文の条件式と初期化を分離](---)  |if (init; condition) のように初期化と条件式を分けて記述できる                                　　  |
|[[fallthrough]]属性                          |フォールスルー時の警告を抑制。「[switch文](---)」参照                                              |
|[constexpr if文](---)                        |if constexpr(cond) とすることで、その if 文はコンパイル時に処理                                    |
|[範囲for文のイテレータ型の不一致の許可](---) |std::istream_iteratorとstd::istreamに利用                                                          |
|[ラムダ式での\*thisのコピーキャプチャ](---)  |キャプチャリストに\*this を指定することで、\*thisをコピーキャプチャする                            |
|[constexprラムダ](---)                       |ラムダ式の関数オブジェクトのconstexpr指定を可能に                                                  |

### 新機能、規制緩和の例
#### 単一要素の波カッコ初期化を非配列とする

```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #0:0 begin
```

#### enum class変数の初期値のルール変更

```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #1:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #1:1 begin
```

#### newのアライメント指定

```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #2:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #2:1 begin
```

#### if文とswitch文の条件式と初期化を分離

```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #3:0 begin
```

#### 範囲for文のイテレータ型の不一致の許可
```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #4:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #4:1 begin
```

#### ラムダ式での\*thisのコピーキャプチャ

```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #5:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #5:1 begin
```

#### constexprラムダ

```cpp
    // @@@ example/cpp_improve/cpp17_ut.cpp #6:0 begin
```

## C++20の主な新規機能
### 構文の新機能、規制緩和

|機能                                           |説明                                                                                                |
|:----------------------------------------------|:---------------------------------------------------------------------------------------------------|
|[三方比較演算子](---)                          |`<=>`/`==`による比較演算子の自動定義                                                                |
|ビットフィールドのメンバ変数初期化             |ビットフィールドメンバ変数のデフォルト値を設定する構文を追加                                        |
|[関数を条件付きでexplicitにする構文](---)      |explicit(true) のように explicit に真理値パラメータを指定できるようにする                           |
|const修飾されたメンバポインタの制限を修正      |`.*`演算子での[lvalue](---)のconstメンバ関数呼び出しを許可                                          |
|デフォルトコピーコンストラクタの規約のバグ修正 |デフォルトのコピーコンストラクタと引数が非constなコンストラクタが衝突する問題を修正                 |
|特殊化のアクセスチェック                       |                                                                                                    |
|no_unique_address属性追加                      |[[no_unique_address]]属性を導入し、空の型のオブジェクトをほかのオブジェクトと共有する最適化を許可   |
|[friend指定された関数内から構造化束縛](---)    |構造化束縛でのメンバ変数へアクセスルールの変更                                                      |
|[構造化束縛カスタマイゼーションルール変更](---)|構造化束縛がカスタマイゼーションポイントを見つけるルールを緩和                                      |
|関数の戻り値型の抽象型のチェック               |関数の宣言段階では、パラメータや戻り値型が抽象型かどうかをチェックしない                            |
|可変長データを扱うクラスの効率的なdelete       |クラスのdelete演算子が呼び出される前にデストラクタが呼ばれないようにするオプションを追加            |
|条件付きで特殊メンバ関数をトリビアルに定義     |制約によってトリビアルな特殊メンバ関数と非トリビアルな特殊メンバ関数をオーバーロード可に            |
|未初期化領域への暗黙的なオブジェクト構築       |未初期化領域の利用時に自動的にトリビアルな型のオブジェクトを構築する                                |

### 構文の新機能、規制緩和の例
#### 関数を条件付きでexplicitにする構文
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #0:1 begin -1
```

#### friend指定された関数内から構造化束縛
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #1:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #1:1 begin -1
```

#### 構造化束縛カスタマイゼーションルール変更
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #2:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #2:1 begin -1
```

### template関連

|機能                                                 |説明                                                                            |
|:----------------------------------------------------|:-------------------------------------------------------------------------------|
|[コンセプト](---)                                    |キーワードconcept、requiresの導入。テンプレートパラメータの制約。               |
|[関数テンプレートの簡易定義](---)                    |[ジェネリックラムダ](---)と同様に関数パラメータをの型をauto にすることができる。|
|[型の文脈でtypenameの省略を許可](---)                |型しか現れない文脈では、typenameの省略を可能に                                  |
|[非型テンプレートパラメータとしてクラス型を許可](---)|                                                                                |
|ADLのバグ修正                                        |[関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正](---)    |
|[structテンプレートのテンプレート引数推論](---)      |                                                                                |
|テンプレート引数推論の改善                           |[エイリアステンプレート経由でのクラステンプレートのテンプレート引数推論](---)   |


### template関連の新機能、規制緩和の例
#### 関数テンプレートの簡易定義
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #3:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #3:1 begin -1
```

#### 型の文脈でtypenameの省略を許可
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #4:0 begin
```

#### 非型テンプレートパラメータとしてクラス型を許可
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #5:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #5:1 begin
```

#### 関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #6:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #6:1 begin -1
```

#### エイリアステンプレート経由でのクラステンプレートのテンプレート引数推論
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #7:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #7:1 begin -1
```

#### structテンプレートのテンプレート引数推論
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #8:0 begin
```
```cpp
    // @@@ example/cpp_improve/cpp20_ut.cpp #8:1 begin -1
```


