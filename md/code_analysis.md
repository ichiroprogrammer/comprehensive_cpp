# コード解析
本ドキュメントでは、ソースコードの品質を向上するために下記のような様々な方法を推奨する。

* [自動単体テスト](---) 
* [自動統合テスト](---)
* [コードインスペクション](---)
* ツールによるコード解析

ツールによるコード解析(以下、単にコード解析と呼ぶ)とは、
開発対象のソフトウェアの仕様とは無関係に発見できるバグやその類、セキュリティホール、
コーディングルール不順守、その他のソースコード記述の問題を発見するための検出手段であり、
動的、静的に分類される。
静的コード解析には、以下のようなものがある。

1. ソースコードの記述自体の解析
2. 実行形式バイナリコードの解析
3. 各種メトリクスやリバースエンジニアリングツールを用いた解析

本章では、無償のオープンソースで実施できる静的解析1と動的解析について解説を行う。

## コンパイラによる静的解析
コンパイラによる静的解析とは、コンパイラの警告出力を使用する解析である。
静的解析の中で最も手軽に実施することができるが、
意外なほど多くのソフトウェア開発でおざなりにされている。

多くのコンパイラでは警告をエラーとして扱うオプションが用意されているため、
それをオンにしたビルドをすることで、多くのバグやバグの元となり得るコードを排除できる。

### g++の警告機能
本ドキュメントのサンプルコードは、
以下のような[g++](---)/[clang++](---)の警告機能を使用してビルドを行っている。

```Makefile
    -Werror -Wall -Wextra -Weffc++
```

また、[演習](---)で使用するコードに関しては、あえて問題のあるコードを記述するため、
下記のようなオプションを使用し一部の警告を抑止している。

```Makefile
    // @@@ exercise/programming_convention_q/Makefile #0:0 begin
```

実際のコードによりこの効果を例示する。

```cpp
    // @@@ example/code_analysis/code_analysis.cpp #0:0 begin -1
```

上記コードでは、int32_tであるxとuint32_tであるyを比較することにより、xがuin32_tに型変換されるため、
数学的には自明な x < y が成立しない。
「[算術型|整数型](---)」で述べたルールに違反したために発生する問題であるが、
その検出はg++により下記のように行うことができる。

```cpp
    // @@@ example/code_analysis/warnings/GCC.txt #0:0 begin
```

次のコードは、[Pimpl](---)パターンの誤った実装よってメモリリークを引き起こす
(「[delete](---)」参照)。

```cpp
    // @@@ example/code_analysis/code_analysis.cpp #0:1 begin
```

このように連続的に記述されている場合は、コードインスペクションで発見できるかもしれないが、
クラスの規模がある程度大きくなれば、このような問題を目視で発見することは容易ではない。
一方でg++は下記のように、いとも簡単にそれを指摘する。

```cpp
    // @@@ example/code_analysis/warnings/GCC.txt #0:1 begin
```

また、「[move処理](---)」
で触れたようなパフォーマンスに悪影響のある下記のようなコードに対しても、
g++は適切な指摘をすることができる。

```cpp
    // @@@ example/code_analysis/code_analysis.cpp #0:2 begin
```

```cpp
    // @@@ example/code_analysis/warnings/GCC.txt #0:2 begin
```

### clang++の警告機能
clang++にもg++と同様の優れた警告機能が備わっているが、それらは実装が異なるため、
下記のような混乱を引き起こすコードに対して(「[オーバーライド](---)」参照)、
clang++は、g++ができない問題点の指摘を行うことができる。

```cpp
    // @@@ example/code_analysis/code_analysis.cpp #1:0 begin
```

```cpp
    // @@@ example/code_analysis/warnings/CLANG.txt #1:0 begin
```

こういった問題があるため、両コンパイラによるコンパイルを薦める。

## scan-buildによる静的解析
scan-buildはclang++をベースにした静的解析ツールであり、
コンパイラの警告機能では指摘できないバグやバグの元となり得るコードを指摘できる。

まずは、問題のあるコードを以下に示す。

```cpp
    // @@@ example/code_analysis/code_analysis.cpp #2:0 begin
```

上記クラスIllegalShallowCopyは、オブジェクトをnewにより生成し、そのポインタをメンバ変数として持つ。
このようなクラスに対しては[ディープコピー](---)を実装するか、
オブジェクトのコピーを禁止すべきであることは、「[コンストラクタ](---)」で述べた通りである。

こういったコードに対して、g++/clang++はその問題を発見できないが、
scan-buildは下記のように適切な指摘を行うことができる。

```cpp
    // @@@ example/code_analysis/warnings/scan-build.txt #2:0 begin
```

次に示すのは、
「[RAII(scoped guard)](---)」に従わなかったために発生した潜在的バグを含んだコードである。

```cpp
    // @@@ example/code_analysis/code_analysis.cpp #2:1 begin
```

こういったコードに対しても以下に示す通り適切なメッセージを出力する。

```cpp
    // @@@ example/code_analysis/warnings/scan-build.txt #2:1 begin
```

scan-buildは以下のような方法で簡単に使用できるため、
C++でのソフトウェア開発における必須アイテムの一つであるといえる。

	    > scan-build make

## cppcheck静的解析
cppcheckはscan-buildと同様な静的解析ツールであり、
コンパイラの警告機能では指摘できないバグやバグの元となり得るコードを指摘できる。

まずは、問題のあるコードを以下に示す。

```cpp
    // @@@ example/code_analysis/code_analysis.cpp #3:0 begin
```

問題は、配列への不正アクセスであり、これは未定義動作につながる典型的なバグであるが、
scan-buildでは発見できない。

cppcheckはこういったコードに対して以下に示す通り適切なメッセージを出力する。

```cpp
    // @@@ example/code_analysis/warnings/cppcheck.txt #1:0 begin
```

このバグは、後述するsanitizerで発見できるものの、静的解析で発見できた方が当然ながら好ましい。

cppcheckは以下のような方法で簡単に使用できるため、
C++でのソフトウェア開発における必須アイテムの一つであるといえる。

        > bear make --always-make       # compile_commands.jsonの生成
        > cppcheck --project=compile_commands.json 2> cppcheck_bugs.txt

## sanitizerによる動的解析
本ドキュメントで扱うsanitizerとは、無償で利用できるC/C++動的解析ツールである。
sanitizerオプションをオンにしたg++/clang++でテスト対象をビルドし、
生成された実行形式バイナリを駆動することで使用することができる。

サンプルコードをsanitizerで解析するために使用したg++/clang++のコンパイルオプションを以下に示す。

```
    -fsanitize=address,leak,undefined,float-divide-by-zero,float-cast-overflow
```

これらのオプションは、g++/clang++共通である。

このオプションを使用した実行形式コードがどのように動作するのかを例示するために、
まずは、動的解析対象のコードを下記する。

```cpp
    // @@@ example/code_analysis/code_analysis.cpp #4:0 begin
```

上記コードは、「[継承/派生](---)」で説明した内容(基底クラスのデストラクタはvirtual)に反するため、
メモリ管理にstd::unique_ptr<>を使用しているにもかかわらずメモリリークを引き起こす。
g++/clang++/scan-build/cppcheckはこの問題を指摘できないが、
sanitizerは以下のような出力によりメモリリークを指摘することができる。

```cpp
    // @@@ example/code_analysis/warnings/sanitizer.txt #3:0 begin
```

次に示すコードは、型が違うインスタンスへの代入によりオーバーフローを起こしてしまう例である。
先に示したコード同様、
g++/clang++/scan-build/cppcheckでは指摘されない問題がsanitizerにより指摘される。

```cpp
    // @@@ example/code_analysis/code_analysis.cpp #4:1 begin -1
```

```cpp
    // @@@ example/code_analysis/warnings/sanitizer.txt #3:1 begin
```

sanitizerは以上に示した通り極めて優れたバグ検出能力を持つが、
動的解析の特性からソースコードに上記のようなバグがあってもそれが実行されなければ、
そのバグは指摘されない。

また、このような指摘をするためのコードは実行形式バイナリの中にコンパイル時に組み込まれるため、
以下のような問題が発生する。

* ランタイム動作が遅くなる。
* ビルド時間が延びる。
* 実行形式バイナリのファイルサイズが巨大になる。

このためプログラミングの最中に行われる動作確認や手作業でのシステムテスト(特に組み込みソフトウェア)
に用いる実行形式バイナリにsanitizerを適用することは難しい。

従って、[CI(継続的インテグレーション)](---)の一環で行われる
[自動単体テスト](---)や[自動統合テスト](---)でのsanitizerの使用を薦める。


## まとめ
以上で述べてきたようにコード解析ツールにはそれぞれ得手不得手があり、完璧なものは存在しないため、
これらを組み合わせてコード品質の向上に努める必要があるが、
これらの実施が各プログラマによって個別に行われるのであれば、
コンパイル時間の増大等による新たなロスが発生する。

上記や「[CI項目の例](---)」で述べたように自動化によって、こういったロスを回避しつつ、
様々なコード解析ツールを組み合わせて使用することが効率的なプロセスの要件となる。


