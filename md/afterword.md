# あとがき

すでに述べたように組織のソフトウェア開発能力は、以下の三要素に基づいている。

* [インフラ](---)
* [あとがき|プロセス](---)
* [プログラマ(人材)](---)

それぞれの観点から、ソフトウェア開発に未熟な組織について考察してみたい。

___

[インデックス](---)に戻る。  

## インフラ

ソフトウェア開発においてインフラとは、

* コンパイラ
* デバッガ
* IDE/エディタ
* 単体テストフレームワーク

のようなプログラマが直接使用するツールに加えて、

* バージョン管理システムやそのウェブサービス
* CIサーバ(Jenkinsのようなもの)
* 静的解析ツール

のようなプログラマを陰で支えるツール等がある。
概ねそれらは安価もしくは無料で入手できるため、
もしそれらを使っていない(もしくはそれらの性能を十分に引き出していない)のであれば、
その理由は予算がないことではない。

多くのソフトウェア開発は、何もないところから始まらない。
前リリースのソースコードを起点として、次期開発を行うことがほとんどである。
とすれば、 開発の起点となるソースコードは上記インフラよりもはるかに重要なインフラであることに気づく。

自明のことであるが、次期ソフトウェアの開発効率はこのソースコードの品質に強く依存する。
このことはよく知られているはずなのに、品質の悪いソースコードを捨てることも、
改善することもなく次期開発開の起点にしてしまう理由は何なのだろうか？  

「便利なツールを使っていない(使いこなしていない)」前者にしても、
「品質の悪いソースコードを使い続ける」後者にしてもにしても、
「あるべき姿になっていない」ことは共通している。
そして、その言い訳として「工数がない」のである。
残念ながらこの分析は間違っている。工数不足は原因ではなく結果である。

## プロセス

組み立て工場において、製造工程に工員の高度な技量や知識は不要である。
そのため、極端に言えば誰がやってもほぼ同じものを作ることができる。
製品の組み立て工程が、高度な技量や熟練を必要としないようにデザインされているからであり、
これが可能になる理由は、組み立て行為が単純作業であるためである。

ソフトウェア開発には、複雑で高度な思考、意思決定が必要となるため、
誰がやっても同じ成果物を作り出せるようなプロセスのデザインは不可能である。
にもかかわらず、ソフトウェア開発に組み立て工場のアナロジーを持ち込み、
誰がやっても同じ成果物を作り出せるようなプロセスをデザインしようとする人々がいる。

それとは逆に、ソフトウェア開発は融通無碍であるべきとばかりに、
何のルールもなくカウボーイスタイルのプログラミングが横行するチームもある。
主張の強いプログラマがこのような思想を持ち、
マネージメントが機能しないとこのようなカオス状態のソフトウェア開発が行われる。

前者をプロセス万能主義、後者をプロセス無力主義と呼ぶことにする。
万能主義、無力主義どちらの場合も、プロセスに対する無知がその根底にある。
この二つは対極的な思想に思えるが、現場の混乱、非効率な開発、
バグだらけのソフトウェア等の同様な現象を引き起こす。

万能主義は、さらに大きな問題を引き起こす。
効果が疑わしいプロセス(解読困難なソースコードのレビュー等)を押しつれられたプログラマは
いずれやってもいないことをやったことにしてしまう。
これによって引き起こされたモラルハザードはさらにソフトウェア開発を難しくする。

この両チームより少しだけ気の利いたチームは、
万能主義にも無力主義に陥ることなくアジャイル系プロセスを導入することで改善を始める。
ただし、ハードルの高いキープラクティス
(単体テストや統合テストの自動化、CI等)の導入は無視してしまう。
そして数か月後、無視したプラクティス無しではそのプロセスは役に立たないことを証明してしまう。

このようなチームのリーダーやマネージャに「なぜこんなことになったのか？」と問えば、
改善する「工数がなかった」と答えるだろう。
残念ながらこの分析も間違っている。工数不足は原因ではなく結果である。

## プログラマ(人材)

前述したとおり、

* 工数不足が原因となって、不適切なインフラやプロセスを使うという結果になった。

という主張は、ほとんどの場合、因果関係が逆である。

* 不適切なインフラやプロセスを使うことが原因となって、工数不足という結果に陥った。

というのが実状に近い。では、適切なインフラやプロセスを使えない原因は何だろうか？

良いソースコードは良いプログラマにしか書けず、知識豊富なプログラマのみが開発用ツールを使いこなす。
プロセスについても同様で、比較的容易に導入できるといわれているSCRUM等の軽量プロセスであっても、
高いレベルのプログラマ無しで導入・運用することは不可能である。

つまり、優れたプログラマ無くして適切なインフラ構築やプロセス運用はできないのである。
従って、不適切なインフラやプロセスを使い続ける原因は、その組織の人材不足である。

ソフトウェア開発に必要な知識を、単なる経験のみから得ることはほぼ不可能である。
実際に10年以上の経験を持ち、且つほとんど素人といってよいプログラマは珍しくない。
彼らの問題は、先人の知恵に学ばない(書籍やドキュメントをほとんど読まない)ことである。
このため、長い経験の中で行ったトライ&エラーから得られる断片知識だけが彼らのよりどころである。

エディタ、コンパイラといった基礎的なツールですらマニュアルを熟読せずに、
その使用方法を習得するこはできない。にもかかわらず、彼らはそれをしない。
その代償として、経験だけは長い素人が出来上がる。

ソフトウェア開発の問題の根本原因はこれである。
従って、この問題に着手せずに、他の問題は解決しない。

## まとめ

ここまでの結論は、

* 不足しているのは工数ではなく知識である。
* 知識不足の解決がソフトウェア開発能力改善の必要条件である。

したがって、ソフトウェア開発能力の改善を行いたいのであれば知識の習得(＝学習)が不可避である。
「学習する工数等ない」との主張が聞こえてきそうだが、本当にその主張は正しいだろうか？

まずは、「7つの習慣」から拝借した下図を見てほしい(「[ノコギリの刃を研ぐ](---)」も参照)。

![重要度・緊急度マトリックス](plant_uml/7_habits.png)

この図は、組織(や個人)が行う仕事を

* 横軸：重要度
* 縦軸：緊急度

の観点から4つに分類するためのものである。

どんな組織だろうが第１領域(緊急かつ重要、定常業務)の仕事から手を付ける。
ソフトウェア開発を主な業務とする組織の第1領域の仕事とは、
ソフトウェア開発そのものやそれにまつわるソフトウェアのトラブル対応等だろう。
未熟な組織においてもこの選択を間違えることはない。

問題はその次の選択である。第２領域(緊急だが、重要でない)の仕事に手を付けてしまうのである
(ミーティング、電話、メール等の雑務で、本当に必要なものは全体の何パーセントだろうか？)。

これらに工数を投入してしまうと、第３領域(緊急でないが重要。学習はその代表)に割り当てる工数はなくなる。
逆に言えば第２領域よりも第３領域のプライオリティを高くすることのみが、第３領域に対処する方法である。

これは言うよりも簡単でないことは確かだが、
これをしない限り第３領域(学習)への時間割り当てができず、したがって組織の知識不足も解決しない。
知識不足が解決できないのであれば、 工数不足も解決しない
(知識不足によって発生した工数不足に見える状態に、増員で対処しようとしてもほとんど効果はない)。

学習が必要であることに賛成でも、
組織が今抱えている問題の対策にはあまりにも遅く迂遠に感じる人も多いだろう。
そういう人々は、起死回生を図りプロセス改善を始めてしまうこともあるだろうが、
すでに述べた通り、このような拙速な対策が大きな効果を発揮することはまずない
(例えばソースコードレビューはレビューアのスキルが低ければ効果がない)。
さらに悪いことに、この仕事により工数はますます逼迫し、その組織はさらに学習から遠ざかる。

以上の議論をまとめると、ソフトウェア開発能力不足の解決に王道はなく、
その唯一の方法は学習なのである。
組織改善における格言「着眼大局、着手小局」が教えるところに従い、
まずはこのドキュメントをチームで理解することろから始めるのが良いのではないかと思う。

本ドキュメントが、多くのプログラマとその組織が学習に向かう一助になることを願う。


