# ソフトウェアプラクティス

ピーター・ドラッカーは「プロフェッショナルの条件」の中で、

```
    紀元前440年頃、ギリシャ彫刻家フェイディアスはアテネのパンテオンの庇に建つ彫刻郡を完成させたが、
    フェイディアスの仕事の請求書に対して、アテネ会計官は「彫刻の背中は見えない。
    見えない部分まで彫って請求してくるとは何事か」と全額の支払いを拒んだ。フェイディアスは言った。
    「そんなことはない。神々が、人々には見えない彫刻の背中を見ているのだから。」
```

この逸話を用いることで、ドラッカーはこう説いている。
プロフェッショナルとは、外部からの承認や評価を超えて、自己の内なる基準に忠実であり、
たとえ誰の目に触れなくても、最高の品質を追求する人物でなければならない。

そのような誠実な姿勢こそが、自らの専門性と倫理観を高めていくのであり、
それが真にプロフェッショナルであるということなのだ。

プロフェッショナリズムの本質は、単なる知識や技術ではない。
見えない部分にも手を抜かず、全力を尽くす――その深い責任感と献身にこそ、真の価値が宿るのである。

ドラッカーの考えるプロフェッショナルに、
ソフトウェアエンジニアがそのレベルに到達するために重要であると考えられる原則・法則を以下に紹介する。


* プログラマの行動に関する原則・法則
    * [DRYの原則](---)
    * [KISSの原則](---)
    * [ボーイスカウトの規則](---)
    * [YAGNIの原則](---)
    * [Name and Conquer](---)
    * [ノコギリの刃を研ぐ](---)
    * [推定有罪](---)

* デザイン、プログラミングに関する原則・法則
    * [デメテルの法則](---)
    * [コンウェイの法則](---)
    * [Inside-Outの原則](---)
    * [ソフトウェアプラクティス|SOLID](---)

[このドキュメントの構成](---)に戻る。  

___

## DRYの原則
DRYとは、"Don't repeat yourself."の略であることから推測できるように、
「ソフトウェア開発での繰り返し作業や成果物の重複を避けよ」という原則である。

### 作業の繰り返し
ソフトウェア開発におけるプログラマのワークフローは下記のようなものである。

![ワークフロー例](plant_uml/general_workflow.png)

ソフトウェア開発において、この流れの繰り返しは避けられないが、
この一連の作業のうち、少なくとも「ソースコードのビルドとデプロイ」と、
「新規ソースコード周辺の回帰テスト」での手作業のほとんどを自動化により回避可能である。

もし、これらにまつわる作業のほとんどが手動で行われていれば、 これらに多くの工数が奪われる。
また、手作業によるミスは避けられず、それによりさらに多くの工数が奪われる。

容易に推測できるように、これらの自動化は絶大な効果を発揮するため、
生産性改善の必須項目となっている(「[自動単体テスト](---)」、「[自動統合テスト](---)」参照)。

様々な自動化にスクリプト言語の習得が必要ならば、それを良い学習機会と捉えるべきである。
その投資対効果は間違いなく、ポジティブである。

### 成果物の重複
成果物の重複とは、

* コードクローン(ほぼ同じソースコードの断片)
* ソースコードに書いてあることをそのまま自然言語で説明したコメント
* ソースコードを読むことで容易にわかる詳細設計ドキュメント

等を指す。

成果物の重複の中で最も罪深いものはコードクローンである。コードクローンにより、

* ソースコード修正時にその箇所が多岐にわたるため、デグレードや修正漏れの原因になる。
* コードレビューの時間が延びる。
* ビルドが遅くなる。
* リポジトリが不要に大きくなる。

等の様々な問題が発生する。また、コードクローンは、コードクローンの原因にもなるため、
これらの問題は時とともに加速度的に大きくなる。

言語仕様に精通し、プログラミングイデオムや、[|デザインパターン](---)を学び、
その知識を利用して定期的にリファクタリングを行うことでコードクローンの発生は軽減、回避可能である。

## KISSの原則
"Keep it simple, stupid!"の頭文字からなる原則であり、意味は読んで字のごとしである。

「フェルマーの最終定理」で有名なフェルマーは友人にあてた手紙の冒頭で、
時間不足のため手紙が長くなることを謝った。
手紙の推敲不足ならば謝罪で十分だろうが、対象が設計ドキュメントや、ソースコードの場合、
謝罪では問題は解決しない。
なぜなら、そのドキュメントやソースコードは次の開発のベースラインとなるからである。

不要な複雑さを持ったそれらは、明日行うかもしれない次の開発を、間違いなく難しくさせる。
この設計上の負債が一定量を上回れば、それ自体が不要な複雑さを増やす原因となり、
問題はさらに複雑になる。

残念ながら、一旦この負のスパイラルに陥ってしまえば、これを止め、逆転させることは極めて困難であり、
スクラッチから作り直すよりも、多くの工数、スキルを要する。

設計ドキュメントや、ソースコードから不要な複雑さを切り捨て、シンプルに保とう。
時間的制約で、すぐにそれに取り掛かれない場合は、成果物にマーキングを行い、
やるべきことを忘れないようにしよう(マーキングキーワードにはTBR(== to be refactored)を推奨)。
時間ができた時には、そのキーワードを検索し、すぐに整理・整頓、リファクタリングに取り掛かろう。
中国のことわざに「双葉のうちに刈らずんば、斧をもちうる」とある。
斧が必要になる前に、必ずその問題を刈り取ろう。

## ボーイスカウトの規則
ボーイスカウトの規則の元々の意味は、
「山に行ったときよりも、山から帰るときの方がきれいになるように行動せよ」
というものである。転じて、
「チェックアウトされたソースコードよりも、
コミットされるソースコードの方がきれいになるようにプログラミングせよ」
という意味のソフトウェア開発における規則となった。

この規則を守るために、まずはリポジトリへのコミット前に変更差分の自己レビューを行い、
以下のような不要なコードが残っていないかチェックしよう。

* 不要なコメント
* 改行コードの違い
* タイポ
* 不要なスペース文字
* printfデバッグの残骸
* 一時的な#if 0/#if 1

この規則には、もう一点重要な示唆が含まれている。
グローバル変数の多さや、関数の大きさを指摘された時に、「最初から、汚くて．．．」
というような言い訳をするプログラマは珍しくない。それはおそらく真実であろうが、
それでも、もともと汚かったソースコードをさらに汚してしまったのでは、
問題は大きくなるばかりである。
従って、この規則には「グローバル変数やそれらへのアクセス箇所を増やさない」、
「関数をこれ以上大きくしない」程度の努力は常にするべきである、ということも含まれている。

## YAGNIの原則
YAGNI(You ain't gonna need it)とは、「機能(要件)は実際に必要となるまで実装しない」
という原則である。これは、

* 単なる思い付きや予想により、先回りして実装したコードの多くが不要である。
* その時点で必要でない機能は、それが存在するだけで工数を浪費する。
    * ビルド時間や単体テスト時間が余計にかかる。
    * 必要な機能追加に、余計な負担を与える(コードが不要に複雑になる)。
* 本来やるべきことに集中した方が良い結果が得られる。

といったエクストリームプログラミングのエクスパートたちの主張である。
なお、上記の「単なる思い付きや予想」とは、演繹的推論とは異なる。
演繹的推論により、

* 近い将来その機能が必要になる。
* その機能の実装を必要になるまで先送りするよりも、
  今行った方が良い合理的な理由がある(記憶がホットである等)。

というような場合は、この原則の限りではない。

「[コンウェイの法則](---)」でも述べるように、
「レイヤに水平分割されたパッケージ構造を持つソフトウェア」を、
「各チームや個人がそれぞれのパッケージ開発に責任を持つ組織」が開発を行う場合、
レイヤ毎に開発が進められ、各パッケージの結合は後回しにされる。
そのため、各パッケージの開発者は実際に必要になるかどうか確定しないものを開発することになる。
このスタイルは明らかにYAGNIの原則に違反する。
これが、「各チームや個人がそれぞれのパッケージの開発に責務を持つ組織」
が非効率になってしまう理由の一つである。

## Name and Conquer

かつてデカルトは、「困難を分割せよ」といった。
そのままでは複雑すぎて理解不可能な対象物を、分割して理解していく方法は、
現在では「要素還元」や「divide-and-conquer(分割統治)」と呼ばれる。
このdivide-and-conquerは、デカルト以前から、現在に至るまで、そして今後も、
対象物を理解するための極めて有効な手段である。

これと同等に強力な手法がname-and-conquer(命名統治)である。
対象物が適切に命名されてなければ、我々はそれを正確に記憶することが難しい。
正確に記憶できなければ正確に理解できない。
仮に理解できたとしても他者とその理解を共有することは難しい。
一方、それに適切な名前を付けることで、その対象物の理解が始まり、他者との理解の共有が可能となる。
「クラウド・コンピューティング」という命名がその好例である。

以下のような事に気を付け、自分たちが使う概念やソフトウェア構成物に、適切な命名をしよう。

* その名前が持つ意味の揺らぎをプロジェクトから排除する。
* すでにグローバルスタンダードとして存在する名前を別の用途で使わない。
* 自分たちが必要とする概念が、すでにグローバルスタンダードな名前を持つのであれば、
  それをそのまま使用する。
* 新規概念を理解できていないか、それ自体が大きすぎれば、それへの命名は難しい。
  その場合、その概念を分割し、分割された部分に命名する。
* 命名に誤りはつきものである。一旦定めた名前よりも適切なものが見つかった場合、
  その修正を躊躇してはならない。
* XXXコントローラや、XXXマネージャ等の命名は、それらの責務が限定されない場合が多い
  (こういった名前を、「強すぎる名前」と呼ぶ)。もっと限定的な(弱い)名前を付ける。

「[命名規則](---)」に詳細をまとめたので参照してほしい。

## ノコギリの刃を研ぐ
まずは、「[7つの習慣](https://ja.wikipedia.org/wiki/7%E3%81%A4%E3%81%AE%E7%BF%92%E6%85%A3)」
からの引用を紹介する。

```
    森の中で木を倒そうと、一生懸命ノコギリを挽いている樵(きこり)に出会ったとしよう。
      「何をしているんですか」
    とあなたは訊く。すると
    「見れば分かるだろう」
    と、無愛想な返事が返ってくる。
      「この木を倒そうとしているんだ」
      「すごく疲れているようですが．．．。いつからやっているんですか」
    あなたは大声で尋ねる。
      「かれこれもう五時間だ。くたくたさ。大変な作業だよ」
      「それじゃ、少し休んで、ついでにそのノコギリの刃を研いだらどうですか。
        そうすれば仕事がもっと早く片付くと思いますけど」
    あなたはアドバイスをする。
      「刃を研いでいる暇なんてないさ。切るだけで精一杯だ」
    と強く言い返す。
```

残念ながら、ソフトウェア開発現場でも、この滑稽な状況を頻繁に目にする。
このようになりたくなければ、定期的にノコギリの刃を研ぐことである。
そのヒントを下記する。この他にもたくさんあるはずである。

* タッチタイピングや開発ツールのショートカットを身に着ける。
* すぐれたエディタやIDEを使いこなす。
* printfデバッグのみに頼ることはやめて、すぐれたデバッガ(「[デバッガの使用](---)」参照)を使う。
* 「[DRYの原則](---)」を実践し、繰り返しの手作業をなくすためのツールを導入、開発する。
* 静的・動的解析ツールを利用し、最小の努力でバグやバグの元になる質の悪いコードを見つけ改善する。
* オープンソースを利用する。
* 新しい言語や、使い慣れた言語の最新機能を学ぶ。
* 効率的なプロセスを理解し、導入する。
* 定期的に書籍やウェブから最新技術情報を入手する。

こういったことに何一つ取り掛からないのであれば、「時間がない」とつぶやきながら、
切れないノコギリを挽き続けることになる。

## 推定有罪
言うまでもなく、**推定無罪**とは「何人も、有罪を宣告されない限り無罪である」という原則であり、
この順守は近代国家であるための必要条件となっている。
これは人権を守るといった観点のみでなく、
「[悪魔の証明](https://ja.wikipedia.org/wiki/%E6%82%AA%E9%AD%94%E3%81%AE%E8%A8%BC%E6%98%8E)」
という言葉で表されるような「多くの場合、無罪の証明は技術的に困難である」
といった観点でも重要な原則である。
我々がそういった原則を順守している国家に属していることは大変結構なことではあるが、
この原則はソフトウェア開発においては当てはまらない。
にもかかわらず、これをソフトウェア開発に持ち込むプログラマがいる。

そういったプログラマの行動パターンは以下のようなものである。

* プログラミングルールを守らない。
* ソフトウェア工学的に良くないことだと知りつつ、下記のようなことを行う
  (おそらく、下記が良くないことであると知らないプログラマはいないだろう)。
    * グローバル変数を作る。
    * 巨大なソフトウェア構成物(ファイル、クラス、関数等)を作る。
    * コピー&ペースト・プログラミングをする(コードクローンを作る)。
    * コンパイラや静的解析ツールの警告を無視する。
* ソースコードのコミットに際して、プログラマが当然すべき以下のような作業をしない。
    * コミット予定のソースコードの自己レビューをする。
    * コミット予定のソースコード周辺の回帰テストをする。
    * コミット後、それを別のリポジトリにチェックアウトする等して、
      コミットに抜け漏れが無いかを確認する。
    * コミット後のデグレード発生に対して、リポジトリ先頭の品質を回復させる。
* 会議等の時間を守らない。
* 自分のスキルの低さを気にしない。

等々挙げればきりがない。
これらの行動は、どの一つをとっても、組織やその組織の成果物を直ちに棄損したと証明することは難しいため、
推定無罪の原則を適用すれば、このプログラマの行動は無罪である。

良識あるプログラマから見れば、明らかに有罪である行動が無罪になる理由は、
その論拠となる原則が間違っているからである。
ソフトウェア開発の現場においては、常に**推定有罪**「無罪を証明しない限り有罪」の原則が正しい。
とは言え、先に書いたようにそれは「悪魔の証明」をすることになり、実践的には不可能である。

故にソフトウェア開発の現場における推定有罪の原則とは、
「無罪であると演繹推論できるものは無罪という前提の元、無罪を証明しない限り有罪である」
というようなものである。

この観点に従って、上記推定無罪プログラマの行動パターンを矯正すると下記のようになるだろう。

* プログラミングルールを守る。
* ソフトウェア工学的に良くないことはしない。
* ソースコードのコミットに際して、最低でも下記のような作業を行う。
    * コミット予定のソースコードの自己レビューをする。
    * コミット予定のソースコード周辺の回帰テストをする。
    * コミット後、それを別のリポジトリにチェックアウトする等して、
      コミットに抜け漏れが無いかを確認する。
    * コミット後のデグレード発生に対して、リポジトリ先頭の品質を回復させる。
* 会議等の時間は守るか、守れない場合は前もって、その旨を開催者に伝える。
* 自分のスキルに気を配り、常に向上に努める。

当たり前のことであるが、意外なほど多くのプログラマが出来ていない。

## デメテルの法則
最小知識の原則(Principle of Least Knowledge)とも呼ばれ、

* オブジェクトは、それ以外の構造やプロパティに対して(他のオブジェクトに対して)持っている知識、
  前提を最小限にすべきである。

という設計上の制約である。

クラスAから生成されたオブジェクトaが、クラスBから生成されたオブジェクトbのメンバ関数
「void\* B::f()」を呼び出し、戻りのポインタを何らかの型にキャストして使用するようなコードは、
この法則違反となる。
当然ながら、型付けの厳格なC++の仕様の裏をかくこのような記述は避けなければならない。

オブジェクトaが、オブジェクトbのメンバ関数「C& B::f()」を呼び出すことにより、
クラスCから生成されたオブジェクトcにアクセスし、
そのメンバ関数「C::g()」を呼び出す「a.f().g()」のような多重の呼び出しもこの法則違反となるが、
この例でのクラスCがstd::string constのように状態が不変で安定した仕様を持つならば、
このような多重呼び出しが問題になることは稀である。
一方で、この法則に従うと、クラスBにC::g()のラッパー関数を作ることになるため、
これをプロジェクト全体で守れば、多量のラッパー関数を作らざるを得なくなる。
その結果として、多くのクラスの凝集性(「[クラスの規模|凝集度](---)」参照)が低下する。

これらを総合して考えると、 上記オブジェクトcが「ミュータブルである」、
もしくは「仕様が流動的である」ときのみにこの法則を適用するべきである。

## コンウェイの法則
[コンウェイの法則](https://en.wikipedia.org/wiki/Conway's_law)とは、
「システムを設計する組織は、その構造をそっくりまねた構造の設計を生み出してしまう」
現象を説明するものである。

ソフトウェア開発を行う組織は、ドメイン知識に基づいた組織構造
(GUIチーム、ミドルウエアチーム、ドライバチーム等）を持つことが多い。
こういった組織が、コンウェイの法則に陥ってしまうと、

* ソフトウェア全体を、水平にパッケージ分割したアーキテクチャを構築する
* ドメイン組織に基づいたチームは、このパッケージの開発責任を持つ

ことになる。これは合理的な組織統治に思えるが、以下のような避けがたい問題を生み出す。

* パッケージのインターフェースや責務の修正には、組織間での調整会議が必要となる。
  この会議には、多くの意思決定者が参加することになるが、
  この会議参加者のインセンティブはさまざまであるため
  (自分のチームの責任範囲を小さくしたいという意図も働く)、
  この会議での意思決定が技術的最適解になることは稀である。
* 大規模なソフトウェア開発では、パッケージのこのような修正は不可避であり、
  そのたびに上記会議を招集することになる。参加者全員が理解できる言語は自然言語のみであるため、
  この会議の趣旨を説明するためのパワーポイント資料を作ることになる。
  このパワーポイント資料を作ることができる人員は、通常、優秀なプログラマであるため、
  ただでさえ不足しがちな優良なヒューマンリソースをさらに不足させてしまう
  (この状態が定常化しパワポ資料ばかりを作っている、
  かつて優秀だった元プログラマをパワーポッターと呼ぶ）。

また、このような組織構造は、各チームを担当パッケージの開発に集中させてしまうため、 
ソフトウェア全体の開発責務(要件開発責務)の所在があいまいになる。
これにより、以下のような問題も生み出す。

* ソフトウェア全体として統一的に必要な要件(ログ、独自のアサート機能、共通ライブラリ)
  がおざなりにされ、パッケージごとにそのためのライブラリが作られるか、
  そのようなものは一切作られないことになる。
  何れにしても全体として統一感のないソースコードが出来上がる。
* 「[YAGNIの原則](---)」に違反するため、要件の実装とは無関係なコードが作られる。
* 下位パッケージに依存する上位パッケージは、下位パッケージの進捗に強い影響を受け、
  上位パッケージほど進捗が遅れる。
* 全パッケージが完成するまでソフトウェア全体のテストができないため、
  ソフトウェア全体の進捗率を正しく計測することができない。

かくして、このような組織は、

* 長いミーティングが多く、そこでの意思決定は技術的最適解には程遠い。
* かつて優秀だったプログラマは、今ではパワーポイント資料作りを主な業務とするパワーポッター。
* 進捗率が、人の意思によってきめられており、進捗遅れが頻発する。
* 統一感がなく、不要に複雑で、クローンだらけのソースコードを作る。

これを防ぐためには、「ドメイン知識に基づいた組織構造をそのままソフトウェア開発に持ち込む」
ことをやめなければならない。

## Inside-Outの原則
「Inside-Outの原則」というキーワードは「7つの習慣」でも使用されている。
この名著のそれは、
「何らかの問題が起こったときに、それを他責にすることなく(環境や他人の問題)、
まずは自分の管理可能なこと(自分の性格、物事の捉え方、感じ方、動機)に目を向けて対処する」
ことを求める。これは、これで重要な行動規範であるが、
ここで説明する「Inside-Outの原則」はこれとは異なる
(もしかすると、「7つの習慣」からの引用かもしれないが）。

この原則は、GUIアプリケーションを「[MVC](---)」系のアーキテクチャで開発する場合
(それ以外の方法があるとは思えないが)、
「開発はGUI(View)からではなく、Modelから始めよ」という開発手順への制約である。

ViewはModelの画面への表出であり、Viewを表すためにModelがあるわけではない。
まずはModelの関係性を見極めることは、すぐれたGUIアプリケーション開発の要諦である。

ところが、多くのプログラマはGUIから作りたがる。これがModelに悪影響を与え
(もしくは、Viewの中にModelを作りこみ、ViewとModelが癒着した構造を作る)、
容易にデグレードを引き起こす不安定なソフトウェアを作り出す。
このような悪構造は、
「[DRYの原則](---)」で述べたような「回帰テストの自動化」もほとんど不可能にさせる。

Modelから開発を始め、それを外部の「回帰テスト用ソフトウェア」から実行できるようにしよう。
その後、それをViewと組み合わせて実行できるようにすれば、 MVCに基づいたアーキテクチャと、
それを自動テストできるソフトウェアを入手できる。

## SOLID
[SOLID](https://ja.wikipedia.org/wiki/SOLID)とは下記に示す5つの原則である。

* [単一責任の原則(SRP)](---)
* [オープン・クローズドの原則(OCP)](---)
* [リスコフの置換原則(LSP)](---)
* [インターフェース分離の原則(ISP)](---)
* [依存関係逆転の原則(DIP)](---)

この5原則はオブジェクト指向(OOD/OOP)プログラミングにおいて特に重要なものであり、
すべてのプログラマはこれらに従って開発することが求められる。

これらの解説は、「[プログラミング規約](---)」の説明を行った後、
「[|デザインパターン](---)」の直前で行う。


