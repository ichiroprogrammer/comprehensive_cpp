# ソフトウェアプラクティス

ピーター・ドラッカーは著書『プロフェッショナルの条件』の中で、次のような逸話を紹介している。

```
    紀元前440年頃、ギリシャの彫刻家フェイディアスは、アテネのパンテオンの庇に設置される彫刻群を完成させた。
    彼が提出した請求書に対し、アテネの会計官は「見えない部分まで精緻に仕上げる必要はない」として支払いを拒否した。
    これに対しフェイディアスは、「私の仕事は神々に見られている」と答えたと伝えられている。
```


この逸話からドラッカーは、「見えない部分まで完璧に作り込む」という姿勢に、
プロフェッショナルとしての高い倫理観と完全性へのこだわりが表れているとし、
真のプロフェッショナリズムのあり方として紹介している。フェイディアスの教訓は、
プロフェッショナルが目先の利益や他者の評価に左右されることなく、
自らが信じる「完全性」を追求し続ける姿勢の重要性を示している。
ドラッカーはこのような生き方を「integrity（誠実さ・高潔さ）」と呼び、プロフェッショナルに求められる数多くの資質の中でも、最も重要なものであると断言している。

プロフェッショナリズムの本質は、単なる知識や技術にとどまらない。見えない部分にも手を抜かず、
全力を尽くす――その深い責任感と献身こそが、真の価値を生み出すのである。

以下に、ソフトウェアエンジニアがこのプロフェッショナルなレベルに到達するために重要だと筆者が考える原則・法則を紹介する。

* プログラマの行動に関する原則・法則
    * [守破離](---)
    * [DRYの原則](---)
    * [KISSの原則](---)
    * [ボーイスカウトの規則](---)
    * [YAGNIの原則](---)
    * [Name and Conquer](---)
    * [ノコギリの刃を研ぐ](---)
    * [推定有罪](---)

* デザイン、プログラミングに関する原則・法則
    * [デメテルの法則](---)
    * [コンウェイの法則](---)
    * [Inside-Outの原則](---)
    * [ソフトウェアプラクティス|SOLID](---)

[インデックス](---)に戻る。  

___

## 守破離
「守破離」とは、日本の伝統武道、技芸の修行者が歩むべき習熟モデルである。
「守」、「破」、「離」それぞれが以下のような修行者の習熟レベルと、それに基づいた行動規範を表す。

* 「守」- 未熟な修行者であり、まずは、先人の残した「形(型)」を無批判に受け入れ、それを反復すること
* 「破」-「形」に習熟した修行者であり、「形」に自らの工夫を加えながら、より高いレベルを探求すること
* 「離」- 最高レベルに到達した修行者であり、自らが「形」を作り出すこと

ソフトウェアエンジニアリングの世界においても、守破離の成長モデルは極めて有効である。
初学者は、まず確立された原則やパターンを学び、それを忠実に実践することから始める。
やがて経験を積むにつれて、その原則の背景にある本質を理解し、状況に応じた柔軟な適用が可能となる。
そして最終的には、新しい問題に対して独自の解決策を生み出せるレベルに到達する。
このドキュメントが、その成長の一助となることを願っている。

## DRYの原則
DRYとは、"Don't repeat yourself."の略であることから推測できるように、
「ソフトウェア開発での繰り返し作業や成果物の重複を避けよ」という原則である。

### 作業の繰り返し
ソフトウェア開発におけるプログラマのワークフローは下記のようなものである。

![ワークフロー例](plant_uml/general_workflow.png)

ソフトウェア開発において、この流れの繰り返しは避けられないが、
この一連の作業のうち、少なくとも「ソースコードのビルドとデプロイ」と、
「新規ソースコード周辺の回帰テスト」での手作業のほとんどを自動化により回避可能である。

もし、これらにまつわる作業のほとんどが手動で行われていれば、 これらに多くの工数が奪われる。
また、手作業によるミスは避けられず、それによりさらに多くの工数が奪われる。

容易に推測できるように、これらの自動化は絶大な効果を発揮するため、
生産性改善の必須項目となっている(「[自動単体テスト](---)」、「[自動統合テスト](---)」参照)。

様々な自動化にスクリプト言語の習得が必要ならば、それを良い学習機会と捉えるべきである。
その投資対効果は間違いなく、ポジティブである。

### 成果物の重複
成果物の重複とは、

* コードクローン(ほぼ同じソースコードの断片)
* ソースコードに書いてあることをそのまま自然言語で説明したコメント
* ソースコードを読むことで容易にわかる詳細設計ドキュメント
  （例：メソッドの処理フローをそのまま記述したドキュメント。 ソースコードと同期が取れず、かえって混乱を招く）

等を指す。

成果物の重複の中で最も罪深いものはコードクローンである。コードクローンにより、

* ソースコード修正時にその箇所が多岐にわたるため、デグレードや修正漏れの原因になる。
* コードレビューの時間が延びる。
* ビルドが遅くなる。
* リポジトリが不要に大きくなる。

等の様々な問題が発生する。また、コードクローンは、コードクローンの原因にもなるため、
これらの問題は時とともに加速度的に大きくなる。

言語仕様に精通し、プログラミングイデオムや、[|デザインパターン](---)を学び、
その知識を利用して定期的にリファクタリングを行うことでコードクローンの発生は軽減、回避可能である。

## KISSの原則
"Keep it simple, stupid!"の頭文字からなる原則であり、意味は読んで字のごとしである。

「フェルマーの最終定理」で有名なフェルマーは友人にあてた手紙の冒頭で、
時間不足のため手紙が長くなることを謝った。
手紙の推敲不足ならば謝罪で十分だろうが、対象が設計ドキュメントや、ソースコードの場合、
謝罪では問題は解決しない。
なぜなら、そのドキュメントやソースコードは次の開発のベースラインとなるからである。

不要な複雑さを持ったそれらは、明日行うかもしれない次の開発を、間違いなく難しくさせる。
この設計上の負債が一定量を上回れば、それ自体が不要な複雑さを増やす原因となり、
問題はさらに複雑になる。

残念ながら、一旦この負のスパイラルに陥ってしまえば、これを止め、逆転させることは極めて困難であり、
スクラッチから作り直すよりも、多くの工数、スキルを要する。

設計ドキュメントや、ソースコードから不要な複雑さを切り捨て、シンプルに保とう。
時間的制約で、すぐにそれに取り掛かれない場合は、成果物にマーキングを行い、
やるべきことを忘れないようにしよう(マーキングキーワードにはTBR(== to be refactored)を推奨)。
時間ができた時には、そのキーワードを検索し、すぐに整理・整頓、リファクタリングに取り掛かろう。
中国のことわざに「双葉のうちに刈らずんば、斧をもちうる」とある。
斧が必要になる前に、必ずその問題を刈り取ろう。

## ボーイスカウトの規則
ボーイスカウトの規則の元々の意味は、
「山に行ったときよりも、山から帰るときの方がきれいになるように行動せよ」
というものである。転じて、
「チェックアウトされたソースコードよりも、
コミットされるソースコードの方がきれいになるようにプログラミングせよ」
という意味のソフトウェア開発における規則となった。

この規則を守るために、まずはリポジトリへのコミット前に変更差分の自己レビューを行い、
以下のような不要なコードが残っていないかチェックしよう。

* printfデバッグの残骸
* 一時的な#if 0/#if 1
* 不要なコメント
* タイポ
* 改行コードの不統一（CRLF/LF混在）
* 行末の不要な空白文字

この規則には、もう一点重要な示唆が含まれている。
グローバル変数の多さや、関数の大きさを指摘された時に、「最初から、汚くて．．．」
というような言い訳をするプログラマは珍しくない。それはおそらく真実であろうが、
それでも、もともと汚かったソースコードをさらに汚してしまったのでは、
問題は大きくなるばかりである。
従って、この規則には「グローバル変数やそれらへのアクセス箇所を増やさない」、
「関数をこれ以上大きくしない」程度の努力は常にするべきである、ということも含まれている。

## YAGNIの原則
YAGNI(You ain't gonna need it)とは、「機能(要件)は実際に必要となるまで実装しない」
という原則である。これは、

* 単なる思い付きや予想により、先回りして実装したコードの多くが不要である。
* その時点で必要でない機能は、それが存在するだけで工数を浪費する。
    * ビルド時間や単体テスト時間が余計にかかる。
    * 必要な機能追加に、余計な負担を与える(コードが不要に複雑になる)。
* 本来やるべきことに集中した方が良い結果が得られる。

といったエクストリームプログラミングのエクスパートたちの主張である。
なお、上記の「単なる思い付きや予想」とは、演繹的推論とは異なる。
演繹的推論により、

* 近い将来その機能が必要になる。
* その機能の実装を必要になるまで先送りするよりも、
  今行った方が良い合理的な理由がある(記憶がホットである等)。

というような場合は、この原則の限りではない。

「[コンウェイの法則](---)」でも述べるように、
「レイヤに水平分割されたパッケージ構造を持つソフトウェア」を、
「各チームや個人がそれぞれのパッケージ開発に責任を持つ組織」が開発を行う場合、
レイヤ毎に開発が進められ、各パッケージの結合は後回しにされる。
そのため、各パッケージの開発者は実際に必要になるかどうか確定しないものを開発することになる。
このスタイルは明らかにYAGNIの原則に違反する。
これが、「各チームや個人がそれぞれのパッケージの開発に責務を持つ組織」
が非効率になってしまう理由の一つである。

## Name and Conquer

かつてデカルトは、「困難を分割せよ」といった。
そのままでは複雑すぎて理解不可能な対象物を、分割して理解していく方法は、
現在では「要素還元」や「divide-and-conquer(分割統治)」と呼ばれる。
このdivide-and-conquerは、デカルト以前から、現在に至るまで、そして今後も、
対象物を理解するための極めて有効な手段である。

これと同等に強力な手法がname-and-conquer(命名統治)である。
対象物が適切に命名されてなければ、我々はそれを正確に記憶することが難しい。
正確に記憶できなければ正確に理解できない。
仮に理解できたとしても他者とその理解を共有することは難しい。
一方、それに適切な名前を付けることで、その対象物の理解が始まり、他者との理解の共有が可能となる。
「クラウド・コンピューティング」という命名がその好例である。

以下のような事に気を付け、自分たちが使う概念やソフトウェア構成物に、適切な命名をしよう。

* その名前が持つ意味の揺らぎをプロジェクトから排除する。
* すでにグローバルスタンダードとして存在する名前を別の用途で使わない。
* 自分たちが必要とする概念が、すでにグローバルスタンダードな名前を持つのであれば、
  それをそのまま使用する。
* 新規概念を理解できていないか、それ自体が大きすぎれば、それへの命名は難しい。
  その場合、その概念を分割し、分割された部分に命名する。
* 命名に誤りはつきものである。一旦定めた名前よりも適切なものが見つかった場合、
  その修正を躊躇してはならない。
* XXXコントローラや、XXXマネージャ等の命名は、それらの責務が限定されない場合が多い
  (こういった名前を、「強すぎる名前」と呼ぶ)。もっと限定的な(弱い)名前を付ける。

「[命名規則](---)」に詳細をまとめたので参照してほしい。

## ノコギリの刃を研ぐ
まずは、「[7つの習慣](https://ja.wikipedia.org/wiki/7%E3%81%A4%E3%81%AE%E7%BF%92%E6%85%A3)」
からの引用を紹介する。

```
    森の中で木を倒そうと、一生懸命ノコギリを挽いている樵(きこり)に出会ったとしよう。
      「何をしているんですか」
    とあなたは訊く。すると
    「見れば分かるだろう」
    と、無愛想な返事が返ってくる。
      「この木を倒そうとしているんだ」
      「すごく疲れているようですが．．．。いつからやっているんですか」
    あなたは大声で尋ねる。
      「かれこれもう五時間だ。くたくたさ。大変な作業だよ」
      「それじゃ、少し休んで、ついでにそのノコギリの刃を研いだらどうですか。
        そうすれば仕事がもっと早く片付くと思いますけど」
    あなたはアドバイスをする。
      「刃を研いでいる暇なんてないさ。切るだけで精一杯だ」
    と強く言い返す。
```

残念ながら、ソフトウェア開発現場でも、この滑稽な状況を頻繁に目にする。
このようになりたくなければ、定期的にノコギリの刃を研ぐことである。
そのヒントを下記する。この他にもたくさんあるはずである。

* タッチタイピングや開発ツールのショートカットを身に着ける。
* すぐれたエディタやIDEを使いこなす。
* printfデバッグのみに頼ることはやめて、すぐれたデバッガ(「[デバッガの使用](---)」参照)を使う。
* 「[DRYの原則](---)」を実践し、繰り返しの手作業をなくすためのツールを導入、開発する。
* 静的・動的解析ツールを利用し、最小の努力でバグやバグの元になる質の悪いコードを見つけ改善する。
* オープンソースを利用する。
* 新しい言語や、使い慣れた言語の最新機能を学ぶ。
* 効率的なプロセスを理解し、導入する。
* 定期的に書籍やウェブから最新技術情報を入手する。

こういったことに何一つ取り掛からないのであれば、「時間がない」とつぶやきながら、
切れないノコギリを挽き続けることになる。

## 推定有罪
(注：ここでの「推定有罪」はソフトウェア開発における品質管理の原則を表す比喩であり、法律用語としての意味とは異なる。)  
言うまでもなく、**推定無罪**とは「何人も、有罪を宣告されない限り無罪である」という原則であり、
この順守は近代国家であるための必要条件となっている。
これは人権を守るといった観点のみでなく、
「[悪魔の証明](https://ja.wikipedia.org/wiki/%E6%82%AA%E9%AD%94%E3%81%AE%E8%A8%BC%E6%98%8E)」
という言葉で表されるような「多くの場合、無罪の証明は技術的に困難である」
といった観点でも重要な原則である。
我々がそういった原則を順守している国家に属していることは大変結構なことではあるが、
この原則はソフトウェア開発においては当てはまらない。
にもかかわらず、これをソフトウェア開発に持ち込むプログラマがいる。

そういったプログラマの行動パターンは以下のようなものである。

* プログラミングルールを守らない。
* ソフトウェア工学的に良くないことだと知りつつ、下記のようなことを行う
  (おそらく、下記が良くないことであると知らないプログラマはいないだろう)。
    * グローバル変数を作る。
    * 巨大なソフトウェア構成物(ファイル、クラス、関数等)を作る。
    * コピー&ペースト・プログラミングをする(コードクローンを作る)。
    * コンパイラや静的解析ツールの警告を無視する。
* ソースコードのコミットに際して、プログラマが当然すべき以下のような作業をしない。
    * コミット予定のソースコードの自己レビューをする。
    * コミット予定のソースコード周辺の回帰テストをする。
    * コミット後、それを別のリポジトリにチェックアウトする等して、
      コミットに抜け漏れが無いかを確認する。
    * コミット後のデグレード発生に対して、リポジトリ先頭の品質を回復させる。
* 会議等の時間を守らない。
* 自分のスキルの低さを気にしない。

等々挙げればきりがない。
これらの行動は、どの一つをとっても、組織やその組織の成果物を直ちに棄損したと証明することは難しいため、
推定無罪の原則を適用すれば、このプログラマの行動は無罪である。

良識あるプログラマから見れば、明らかに有罪である行動が無罪になる理由は、
その論拠となる原則が間違っているからである。
ソフトウェア開発の現場においては、常に**推定有罪**「無罪を証明しない限り有罪」の原則が正しい。
とは言え、先に書いたようにそれは「悪魔の証明」をすることになり、実践的には不可能である。

故にソフトウェア開発の現場における推定有罪の原則とは、
「無罪であると演繹推論できるものは無罪という前提の元、無罪を証明しない限り有罪である」
というようなものである。

この観点に従って、上記推定無罪プログラマの行動パターンを矯正すると下記のようになるだろう。

* プログラミングルールを守る。
* ソフトウェア工学的に良くないことはしない。
* ソースコードのコミットに際して、最低でも下記のような作業を行う。
    * コミット予定のソースコードの自己レビューをする。
    * コミット予定のソースコード周辺の回帰テストをする。
    * コミット後、それを別のリポジトリにチェックアウトする等して、
      コミットに抜け漏れが無いかを確認する。
    * コミット後のデグレード発生に対して、リポジトリ先頭の品質を回復させる。
* 会議等の時間は守るか、守れない場合は前もって、その旨を開催者に伝える。
* 自分のスキルに気を配り、常に向上に努める。

当たり前のことであるが、意外なほど多くのプログラマが出来ていない。

## デメテルの法則
最小知識の原則(Principle of Least Knowledge)とも呼ばれ、

* オブジェクトは、それ以外の構造やプロパティに対して(他のオブジェクトに対して)持っている知識、
  前提を最小限にすべきである。

という設計上の制約である。

デメテルの法則には主に2つの違反パターンがある。

### デメテルの違反パターン1:型安全性の破壊
クラスAから生成されたオブジェクトaが、
クラスBから生成されたオブジェクトbのメンバ関数「void* B::f()」を呼び出し、
戻りのポインタを何らかの型にキャストして使用するソースコードである。
このような記述は、C++の型システムを迂回するため明らかに問題である。

### デメテルの違反パターン2:多重呼び出し（メソッドチェーン）
オブジェクトaが、オブジェクトbのメンバ関数「C& B::f()」を呼び出すことにより、
クラスCから生成されたオブジェクトcにアクセスし、
そのメンバ関数「C::g()」を呼び出す「a.f().g()」のような多重の呼び出しである。

### この法則の適用の判断基準
パターン1は常に避けるべきである。パターン2については、オブジェクトcが「ミュータブルである」、
もしくは「仕様が流動的である」場合にのみこの法則を適用するべきである。
クラスCがstd::string constのように状態が不変で 安定した仕様を持つならば、
このような多重呼び出しが問題になることは稀である。

## コンウェイの法則
[コンウェイの法則](https://en.wikipedia.org/wiki/Conway's_law)とは、
「システムを設計する組織は、その構造をそっくりまねた構造の設計を生み出してしまう」
現象を説明するものである。

### 典型的なアンチパターン

ソフトウェア開発を行う組織は、ドメイン知識に基づいた組織構造
(GUIチーム、ミドルウエアチーム、ドライバチーム等）を持つことが多い。
こういった組織が、コンウェイの法則に陥ってしまうと、

* ソフトウェア全体を、水平にパッケージ分割したアーキテクチャを構築する
* ドメイン組織に基づいたチームは、このパッケージの開発責任を持つ

ことになる。

### 組織間調整の問題

パッケージのインターフェースや責務の修正には、組織間での調整会議が必要となる。
この会議には多くの意思決定者が参加するが、各参加者のインセンティブはさまざまであり
（自分のチームの責任範囲を小さくしたいという意図も働く）、
技術的最適解に至ることは稀である。

大規模なソフトウェア開発では、このような修正は不可避であり、
そのたびに会議を招集することになる。参加者全員が理解できる言語は自然言語のみであるため、
パワーポイント資料を作ることになる。この資料作成を担えるのは、通常、優秀なプログラマであるため、
ただでさえ不足しがちな優良なヒューマンリソースをさらに不足させてしまう
（この状態が定常化しパワポ資料ばかりを作っている、
かつて優秀だった元プログラマをパワーポッターと呼ぶ）。

### 要件開発責務の曖昧化

このような組織構造は、各チームを担当パッケージの開発に集中させてしまうため、
ソフトウェア全体の開発責務（要件開発責務）の所在が曖昧になる。
これにより、以下のような問題が生じる。

* ソフトウェア全体として統一的に必要な要件（ログ、独自のアサート機能、共通ライブラリ）
  がおざなりにされ、パッケージごとに独自のライブラリが作られるか、
  そのようなものが一切作られないことになる。
* 「[YAGNIの原則](software_practice.md#SS_2_4)」に違反し、要件の実装とは無関係なソースコードが作られる。
* 下位パッケージに依存する上位パッケージは、下位パッケージの進捗に強く影響を受け、
  上位パッケージほど進捗が遅れる。
* 全パッケージが完成するまでソフトウェア全体のテストができないため、
  進捗率を正しく計測できない。

### 結論
かくして、このような組織は以下の特徴を持つ。

* 長い会議が多く、意思決定は技術的最適解には程遠い
* かつて優秀だったプログラマは、今ではパワーポッター
* 進捗率が人の意思によって決められ、進捗遅れが頻発する
* 統一感がなく、不要に複雑で、クローンだらけのソースコードが生まれる

これを防ぐためには、「ドメイン知識に基づいた組織構造をそのままソフトウェア開発に持ち込む」
ことをやめなければならない。

## Inside-Outの原則
この原則は、GUIアプリケーションを「[MVC](---)」系のアーキテクチャで開発する場合、
「開発はGUI(View)からではなく、Modelから始めよ」という開発手順への制約である。

（注：「7つの習慣」でも「Inside-Out」という用語が使用されているが、
そこでは「問題を他責にせず、まず自分の管理可能なことに目を向ける」という
異なる文脈で用いられている。）

ViewはModelの画面への表出であり、Viewを表すためにModelがあるわけではない。
まずはModelの関係性を見極めることが、すぐれたGUIアプリケーション開発の要諦である。

多くのプログラマはGUIから作りたがるが、これがModelに悪影響を与え
（もしくは、Viewの中にModelを作りこみ、ViewとModelが癒着した構造を作る）、
容易にデグレードを引き起こす不安定なソフトウェアを作り出す。
このような悪構造は、
「[DRYの原則](---)」で述べた「回帰テストの自動化」もほとんど不可能にする。

Modelから開発を始め、それを外部の「回帰テスト用ソフトウェア」から実行できるようにしよう。
その後、それをViewと組み合わせて実行できるようにすれば、MVCに基づいたアーキテクチャと、
それを自動テストできるソフトウェアを入手できる。

## SOLID
[SOLID](https://ja.wikipedia.org/wiki/SOLID)とは下記に示す5つの原則である。

* [単一責任の原則(SRP)](---)
* [オープン・クローズドの原則(OCP)](---)
* [リスコフの置換原則(LSP)](---)
* [インターフェース分離の原則(ISP)](---)
* [依存関係逆転の原則(DIP)](---)

この5原則はオブジェクト指向(OOD/OOP)プログラミングにおいて特に重要なものであり、
すべてのプログラマはこれらに従って開発することが求められる。

これらの解説は、「[プログラミング規約](---)」の説明を行った後、
「[|デザインパターン](---)」の直前で行う。


